#+TITLE:The Doomed Configuration
#+DESCRIPTION: A detailed setup for Emacs using Doom Emacs configuration framework
#+AUTHOR: Jamie van Dyke
#+EMAIL: me@fearof.fish

* My Literate Emacs COnfiguration

** About my config
I have built this from a single source

*** Sources:
- [[https://github.com/Townk/doom-emacs-private/blob/master/config.org][Thiago Alves Literate Config]]

*** Identity
Who am I?

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq user-full-name "Jamie van Dyke"
      user-mail-address "me@fearof.fish")
#+end_src

*** Dashboard
Doom Emacs offers a lightweight dashboard, that serves as the landing page for Emacs.

I really like the idea of a dashboard and I like even more what Doom offers, but, the ASCII art for its logo is not something I'm affectionate with.

In order to replace the ASCII art with something more pleasant and thematic, I like to add a small picture on the dashboard:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq +doom-dashboard-banner-dir (expand-file-name "assets" doom-private-dir)
      +doom-dashboard-banner-file "doom.png"
      +doom-dashboard-banner-padding '(0 . 4))
#+end_src

I love the style of this image so much, that it is, besides my dashboard image, my Emacs icon as well. The author of this beauty is [[https://github.com/eccentric-j/doom-icon][Jay Zawrotny]], feel free to send him an accolade!

#+begin_center
#+caption: My favorite contender for a Doom Emacs logo
#+name: fig:caco-demon
[[./assets/doom.png]]
#+end_center

*** Key modifiers
]]Since I use a Mac as my primary computer, I need to adjust its control keys to match a good set of control keys on Emacs:

#+caption: macOS key mappings
#+name: tbl:macos-keys
| macOS Key  | Emacs Key |
|------------+-----------|
| ⌘ (=cmd=)    | ='super=    |
| ⌃ (=ctrl=)   | ='control=  |
| ⌥ (=option=) | ='meta=     |

Emacs expose three variables to allow you to make these adjustments:

- ~mac-command-modifier~
- ~mac-control-modifier~
- ~mac-option-modifier~

To adjust this values according to table [[tbl:macos-keys]], set each one of them to the symbol described on the column =Emacs Key=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq mac-command-modifier 'super
      mac-control-modifier 'control
      mac-option-modifier  'meta)
#+end_src

*** Indentation
On this section, I will ask the reader to disagree on disagree, and set aside the almost religious subject of tabs versus spaces.

I prefer to always indent my files with =2= spaces with some rare exceptions for certain languages. To make Emacs use =2= spaces to indent by default, set the variable ~tab-width~ to =2=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default tab-width 2)
#+end_src

And to force emacs to always use spaces instead of tabs, set the ~indent-tabs-mode~ variable to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

*** Line wrapping
Until the writing of this document, I had the opinion that /soft wrap/ was evil, and it had no place on any editor. Since then, I learned to appreciate /soft wrap/ for prose, and later in this document, you will see all the other setup around /soft wrap/ and have an idea why I was so against it.

To prevent Emacs from wrapping your text as it goes over the size of the screen, set the variable ~truncate-lines~ to a non-=nil= value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default truncate-lines t)
#+end_src

*** Repeatable commands
There is a new feature available since Emacs 28 that allow you to define a /repeatable map/ for actions that take more than one keystroke to perform, and you want to repeat them with only the last keystroke in sequence.

For instance, on Doom, to increase the value of number, you need to use the key binding =g +=. If you want to increase the same number multiple times, you would have to type the same sequence multiple times (ignore the repeat command associated with the =.= key for didactic reasons).

I want to press =g +=, and then multiple keystrokes of =+= to increase the number multiple times, and the ~repeat-mode~ is the new feature that allows me to do that.

In order to use it, you have to define a keymap for the /repeatable keys/, and associate that keymap to the command that will start the repeat. This is an example on how to accomplish that:

#+caption: ~repeat-mode~ example for increment or rotate function
#+begin_src emacs-lisp :tangle no
(defvar my-inc-or-rotate-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "=" 'my-inc-or-rotate-at-point)
    (define-key map "-" 'my-dec-or-rotate-at-point)
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")

(put 'my-inc-or-rotate-at-point 'repeat-map 'my-inc-or-rotate-repeat-map)
(put 'my-dec-or-rotate-at-point 'repeat-map 'my-inc-or-rotate-repeat-map)
#+end_src

This is not bad, but with Lisp we can do better than that! The next macro helps with this process:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defmacro my-repeat-map! (map-name keys-alist &optional docstring)
  "A helper macro to create keymaps for repeatable actions.

MAP-NAME is the variable name for the sparse keymap created, and KEYS-ALIST, is
an association list of functions to keys, where each function is called after
the associated key is pressed after the repeatable action is triggered."
  `(defvar ,map-name
     (let ((map (make-sparse-keymap)))
       (dolist (cmd ,keys-alist)
         (define-key map (cdr cmd) (car cmd))
         (put (car cmd) 'repeat-map ',map-name))
       map)
     ,docstring))
#+end_src

You can find the previous example using the new macro on section [[Plus-Minus]].

In order to be able to use ~repeat-mode~ everywhere, I will turn it on after Emacs initializes:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'repeat-mode)
#+end_src

*** Completion framework
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! vertico
  (vertico-mouse-mode))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! marginalia
  (add-to-list 'marginalia-prompt-categories '("\\<Find file\\>" . file))
  (add-to-list 'marginalia-prompt-categories '("\\<project\\>" . file)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq embark-action-indicator #'my-embark-which-key-action-indicator
      embark-become-indicator embark-action-indicator)
#+end_src

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-embark-which-key-action-indicator (map target)
  "Helper function to display the `whichey' help buffer for embark."
  (which-key--show-keymap "Embark" map nil nil 'no-paging)
  #'which-key--hide-popup-ignore-command)
#+end_src

** Modal editing
As I mentioned on section [[Modal editing]], I do consider /Modal Editing/ far superior then other methods. The main reason is the separation of states while editing a text. At some level, we all do modal editing, but the keybindings style popularized by Vim goes a step forward and /formalize/ these states.

I decided to use Doom as the base of my configuration because it has good reasonable defaults, and its author is also an ex-/Vimer/ like me, so he tailored this distribution with a Vim user in mind.

On Emacs, the package responsible to provide Vim inside Emacs is [[https://github.com/emacs-evil/evil][Evil]], and from all Vim plugins for other editors that I use, Evil is by far the best. So much that compare it with other Vim plugins is doing injustice to Evil developers. More often than not, we call Evil the Vim inside Emacs.

In this section, I will go through configurations and other packages related directly to Evil, so if you don't use Evil or modal editing, feel free to skip this one.

#+begin_center
◆
#+end_center

If you're new to Vim, when you learn about the modes, on of the first /it's weird/ feelings you'll have is when you are in /Normal Mode/, then, you decide to go into /Insert Mode/ by pressing =i=, but right after that, you change your mind and press =<ESC>=... What just happened? You didn't act on anything, you didn't press any movement key, still, the cursor moved one character to the left!

Well, I have to tell you that this behavior is not a bug, is just how we should expect the change of modes to be.

I said /should/, because I disliked this behavior since I first used Vim. I never understood the rationale behind it and I always tried to fix it in my configurations. The good news is, Evil developers added an option to do just that.

To fix the moving back the cursor annoyance, set the variable ~evil-move-cursor-back~ to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-move-cursor-back nil)
#+end_src

After this configuration, one might realize that going to /Insert Mode/ using =a= and pressing =<ESC>= has the opposite effect of moving the cursor to the right. In this case, at least for me, this is an acceptable behavior since the user explicitly requested to go to /Insert Mode/ *after* the current character, is reasonable the editor to move your cursor to the next position.

#+begin_center
◆
#+end_center

On the same lines of /moving back the cursor/, there is another /expected/ behavior of Vim that I don't get it, the infamous /overwriting your clipboard with the contents of a selection that you just paste on top of it/ (I couldn't find a better way to refer to this behavior).

I'm sure that, at some point, this behavior made sense for a lot of developers, but in my personal opinion, if you are pasting the clipboard on top of a selected text, is highly unlikely that you want to use the contents of such selection right after pasting something on top of it. I believe the natural behavior of developers these days, is to consider the selected text you just paste on top of it, as gone.

And just like with the previous annoyance, Evil also offers an option to change this behavior. If you want to *not* copy the content of a selection you just paste something on top of it, set the variable ~evil-kill-on-visual-paste~ to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+end_src

#+begin_center
◆
#+end_center

Because Evil tries to stay faithful to Vim, it does not force Emacs objects into Vim's lingo. One of these examples is the visual selection. Emacs has something called /regions/ that serves, also, to the purpose of selecting text, but in reality, the Vim's visual selection and Emacs' regions, are not the same thing.

However, Evil is an Emacs package, and it also tries to integrate with existent packages and features, and it offers a configuration that makes Evil visual selection, to expand the Emacs selection region when we select something. The net effect of this, is that we can use the terms selection and region interchangeability for all practical purposes.

If you want Evil to synchronize its visual selection with the Emacs region, set the variable ~evil-visual-region-expanded~ to a non-=nil= value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-visual-region-expanded t)
#+end_src

#+begin_center
◆
#+end_center

Evil defines the priority of its highlight in a way that Emacs displays the visual selection overlays bellow search highlights. As of today I can't figure out why this is the case. One workflow pretty common is to search the name of a variable, select its prefix, and search for the rest of the variable. With the default configuration, you can't see what you're selecting until your selections is bigger than the search term.

Unfortunately, Evil hard-code the [[https://github.com/emacs-evil/evil/blob/master/evil-states.el#L624][visual]] [[https://github.com/emacs-evil/evil/blob/master/evil-states.el#L731][priority]] value to 99 for visual selection, which is smaller than the other hard-coded values for the [[https://github.com/emacs-evil/evil/blob/master/evil-search.el#L666][search]] [[https://github.com/emacs-evil/evil/blob/master/evil-search.el#L868][highlight]] overlays, and this was already reported to Evil on issue [[https://github.com/emacs-evil/evil/issues/1089][#1089]] on GitHub.

To fix this, we have to advise ~evil-visual-highlight~ and ~evil-visual-highlight-block~ to bump the overlay priority after these functions execute:

#+caption: autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-evil-visual-highlight-a (&rest _)
  "Make the visual overlay have higher priority than the search highlight."
  :after '(evil-visual-highlight evil-visual-highlight-block)
  (when evil-visual-overlay
    (overlay-put evil-visual-overlay 'priority 1010))
  (when evil-visual-block-overlays
    (dolist (overlay evil-visual-block-overlays)
        (overlay-put overlay 'priority 1010))))
#+end_src

#+begin_center
◆
#+end_center

Vim (therefore also Evil) has this notion of a grammar to execute actions on text:

#+begin_src text :tangle no
{operation}{operator}{target object}
#+end_src

Where /operation/ is the command you're executing, operator can be /i/ (inside) or /a/ (also), and the /target object/ can be any of the targets defined Evil (e.g. /s/ for /sentence/, /p/ for /paragraph/, /[/ for /square brackets content/, etc. ).

One of these target object is /w/ for /word/ and in my experience, the meaning of /"word"/ varies according to context. Let me explain...

If you're editing a text file for blog, the meaning of /"word"/ is most likely the same meaning of the English dictionary, but if you're editing a /Lisp/ code, a word probably include more characters than the conventional /"word"/ (e.g. while /"foo"/ is a word in any context, /"foo-bar"/ is a word, probably only when you're editing a Lisp file).

A quick trick to make Evil understand the meaning of /"word"/ as I just described, is to create an alias for the function ~forward-evil-symbol~, and name it ~forward-evil-word~. This way, we override the normal function to act as if it is the ~forward-evil-symbol~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defalias #'forward-evil-word #'forward-evil-symbol)
#+end_src

** Text snippets
Snippets (also known as Live Templates on certain platforms), are tidbits of text that one can include on the editing text by typing a keyword and pressing a shortcut key (usually =TAB=) with the cursor right after the keyword.

Doom Emacs offers basic configuration for the package /[[https://github.com/joaotavora/yasnippet][Yasnippet]]/, which is the most used snippet system on Emacs.

Most snippet frameworks available across editors (including /Yasnippet/) offer the ability to edit some placeholders on the snippet, so one can have a single snippet and use it on different scenarios. For instance:

Let's assume I'm a Java developer, and as such, one of the most common scenarios is for me to create a class, more or less like this:

#+begin_src java :tangle no
public class MyClassName {
    public MyClass() {
    }
}
#+end_src

I could make this text as a snippet, and I would have to replace =MyClassName= with whatever name I want, but I could go a step further and make my snippet something like this:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1() {
        $0
    }
}
#+end_src

Now, when I expand this snippet, I have the chance to type the name of the class right after expanding it, press =TAB= again, and get my cursor inside the public constructor.

For instance, first I type the snippet keyword (the =|= character represents the cursor, and =[]= represents a selected placeholder):

#+begin_src java :tangle no
myclass|
#+end_src

As soon as I press =TAB=, the snippet expansion happens:

#+begin_src java :tangle no
public class [|MyClassName] {
    public MyClassName() {

    }
}
#+end_src

If I type a different name for the class, the constructor will mirror that change:

#+begin_src java :tangle no
public class AwesomeClass| {
    public AwesomeClass() {

    }
}
#+end_src

And as soon as I press =TAB= again, the cursor moves to inside the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

Another functionality provided by the snippet framework, is the ability to delete a placeholder that does not make sense on the current context. As an example, lets augment our previous snippet with the ability to type arguments on the constructor:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1(${2:args}) {
        $0
    }
}
#+end_src

Now, after renaming the class, if I press =TAB=, I have the chance to type anything as an argument tot the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass([|args]) {

    }
}
#+end_src

If I press =TAB= without typing anything, I would move the cursor to inside the constructor, but would have the word =args= as a parameter definition (which, in Java, is not a valid declaration):

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass(args) {   // <-- Compile error
        |
    }
}
#+end_src

What we want to do here, is to delete the placeholder and move to the next position, and end up with the same result as before:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

By default, we can achieve this by pressing =DEL= instead of =TAB=. In general, this behavior is pretty good, except when you're typing on a MacBook laptop keyboard. MacBook's keyboards don't have the key =DEL= on them, and to get a =DEL=, I have to use a combination of two keys.

For this reason, I want to make sure that the same behavior I have with =DEL=, I also have with =BACKSPACE=.

The following function, is an adaptation of the Doom's own ~+snippets/delete-forward-char-or-field~ function, but doing the reverse of it.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-snippets-delete-backward-char-or-field (&optional field)
  "Delete backward, or skip the current field if it's empty.

Prevents Yas from interfering with backspace deletion."
  (interactive)
  (let ((field (or field (and (overlayp yas--active-field-overlay)
                              (overlay-buffer yas--active-field-overlay)
                              (overlay-get yas--active-field-overlay 'yas--field)))))
    (cond ((not (yas--field-p field))
           (call-interactively #'delete-backward-char))
          ((and (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((eq (point) (marker-position (yas--field-start field))) nil)
          ((call-interactively #'delete-backward-char)))))
#+end_src

With the function defined, I can simply add it to a key bind to start using it. Notice on the following code, that I also map =⌘-RET= to allow me to end the snippet completion and accept all the default values (I'm trying to make =⌘-RET= a standard keymap that means /finish and accept/):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after yasnippet

      (:leader :prefix ("h" . "help")
       :desc "Show snippets" :n "y" #'yas-describe-tables)

      (:map yas-keymap
       :g [backspace] #'my-snippets-delete-backward-char-or-field
       :g [deletechar] #'+snippets/delete-forward-char-or-field
       :g [s-return] #'yas-exit-snippet))
#+end_src

The last configuration for snippets is to guarantee the ~yas-describe-tables~ shows up on the right side of the screen:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*YASnippet Tables\\*"
  :slot 2   :vslot -1     :side 'right   :width 104 :height 0.4
  :select t :modeline nil :autosave nil  :ttl 0     :quit t)
#+end_src

Throughout this document, you will find helpful snippets I like to define for certain features. I decided to spread the snippets across different features because I want to indicate to the reader to consider the snippet in question as an integral part of the configuration at hand.

** Inline completion
What I call inline completion, is also known as intellisense, code completion, or in the Vim world, omni completion. It's a useful tool to help the user type less and more correctly while editing source code.

Years ago, there were two main packages that provided such feature on Emacs:

- [[https://github.com/auto-complete/auto-complete][auto-complete]]
- [[https://github.com/company-mode/company-mode][company-mode]]

On the time I'm writing this part of my document, [[https://github.com/auto-complete/auto-complete][auto-complete]] is searching for a new maintainer, and I barely read any mention of it on the mainstream media.

Since I've been using [[https://github.com/company-mode/company-mode][company-mode]] for the most part of my Emacs experience, I will stick with it on my new configuration.

One of the best features I like on [[https://github.com/company-mode/company-mode][company-mode]], is its architecture design, where the author decided to modularize the package, allowing other packages to integrate with it where they actually matter. For instance, if my package offers a major mode to edit files from the /Foo/ language, I can create a =foo-company-backend= to integrate it on the Company ecosystem, or if my package provides a new cool way to display inline completions, I can create a /company frontend/ to make such integration.

For the most part, Doom does a pretty good job configuring [[https://github.com/company-mode/company-mode][~company-mode~]] to my liking, I just need to adjust some small behaviors and keymaps.

One of the most prominent differences on my configuration is the fact that I don't like to let [[https://github.com/company-mode/company-mode][~company-mode~]] to show its popup automatically. It is a nice feature, but with certain backends, it can slow down the edit experience (I'm looking at you [[https://github.com/company-mode/company-mode/blob/master/company-ispell.el][~company-ispell~]]). For that reasons (and also because I rather the experience of [[https://github.com/ervandew/supertab][=supertab=]] on Vim's world), I decided to not /auto-display/ Company's popup.

In order to display the completion on my configuration, one has to press =TAB= after type couple characters of the word, or type a "=.=" character after a keyword on programming modes that support it.

Such behavior is so wildly used that Company offers a helper function (~company-indent-or-complete-common~) to help the user to handle /inserting a "=\t=" character/ versus displaying the completion. That is all and good, but unfortunately, as seen on section [[Text snippets]], I have a third function for the =TAB= key.

In order to help me handle my three cases for =TAB= I need to create small wrapper function to add the ~yasnippet~ check before handling completion to Company:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-company-indent-or-complete-common (arg)
  "Tab key action for current point.

This function tries to insert a tab character, trigger a snippet or complete a
word with company.

The order for this selection is:

- Org table
- Yasnippet
- Indent region
- Indent line
- Indent org-mode line
- Indent org-mode headline
- Indent org-mode item from a list
- Indent markdown-mode line
- Indent rst-mode line
- Complete with company

The action selection happens in this order and stops as soon as the first action
works."
  (interactive "P")
  (if (org-table-p)
      (orgtbl-tab arg)
    (if (or (not yas-minor-mode)
            (null (yas-expand)))
        (cond ((use-region-p) (indent-region (region-beginning) (region-end)))
              (t (let ((old-point (point))
                       (old-tick (buffer-chars-modified-tick))
                       (tab-always-indent t))
                   (indent-for-tab-command arg)
                   (when (and (eq old-point (point))
                              (eq old-tick (buffer-chars-modified-tick)))
                     (unless (pcase major-mode
                               ('org-mode (or (org-indent-line)
                                              (org-cycle-level)
                                              (org-cycle-item-indentation)))
                               ('markdown-mode (markdown-indent-line))
                               ('rst-mode (rst-indent-line nil))
                               (_ nil))
                       (company-complete-common))))))
      (company-abort))))
#+end_src

This function incorporates the source code of ~company-indent-or-complete-common~ to allow me to handle special cases like in Org mode when I want to indent a list item or headline. It first tries to expand the previous word on a snippet. If it can't, it falls back to the altered Company function, where it also tries to do an Org indent, or a Markdown indent, or a reStructuredText before settling on ~company-complete-common~.

What if I'm already displaying the Company popup, but I want to expand what I just typed into a snippet? The previous function can't help us, because it does not handle navigating the completion options with =TAB=. For such behavior, I need another function that I should run instead of the previous one if I have Company's popup opened:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-completion-yasnippet-or-completion ()
  "Tab key action when company popup is visible.

This function tries to expand a snippet, complete a common prefix on a company
completion, or move the company selction to the next item."
  (interactive)
  (if (or (not yas-minor-mode)
          (null (yas-expand)))
      (company-complete-common-or-cycle)
    (company-abort)))
#+end_src

Notice that the only difference between ~my-company-indent-or-complete-common~ and ~my-completion-yasnippet-or-completion~ is that I call ~company-indent-or-complete-common~ on the former, and ~company-complete-common-or-cycle~ on the latter.

Another deviation from the standard that I like, is how the =RET= should work with Company.

For me, there are two scenarios that can happen if one presses =RET= while the Company popup is visible:

1. The user meant to insert a "=\n=" character on the document;
2. The user intended to select the selected completion option;

The way to distinguish between these two scenarios, is to check if Company already have a selection stored at ~company-selection~. If it does have, the =RET= should represent a ~company-complete-selection~, otherwise, the =RET= should close the Company popup, and insert a "=\n=" character on the document. I created the next function to manage these behaviors:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-completion-complete-selection-or-return ()
  "Return key action when company popup is visible.

This function will select current company item if user already selected one, or
insert a new line character."
  (interactive)
  (if company-selection
      (company-complete-selection)
    (company-abort)
    (execute-kbd-macro (read-kbd-macro "<return>"))))
#+end_src

Notice also, that I didn't use ~insert~ when a =RET= means to /add a new line/. This decision is to allow Emacs to trigger any function or hook tied to the =RET= key.

With all auxiliary functions created, I just need to set up Company according to my needs:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay nil)
  (setq tab-always-indent 'complete)
  (setq company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (setq company-box-doc-enable nil)
  (setq company-frontends (delq 'company-pseudo-tooltip-frontend company-frontends))

  (add-hook 'evil-normal-state-entry-hook #'company-abort))
#+end_src

One configuration that worth mention why I choose it is to set ~company-box-doc-enable~ to =nil=. I did this, not because I don't like the documentation as another child frame, is the fact that if I do show it, I can't move my popup completion without aborting Company.

Last, I need to set up the proper keymaps for the package:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after company
      (:map global-map
       :i [tab] #'my-company-indent-or-complete-common)
      (:map company-active-map
       :g [tab] #'my-completion-yasnippet-or-completion
       :g [backtab] #'company-select-previous
       :g [down] #'company-select-next
       :g [up] #'company-select-previous
       :g [return] #'my-completion-complete-selection-or-return
       :g "C-S-j" #'company-next-page
       :g "C-S-k" #'company-previous-page
       :g "C-/" #'company-show-doc-buffer))
#+end_src

** Automatic indentation
I appreciate the fact that majority of editor these days can keep the indentation of the previous line, and some of them, are even capable of adding indentation where is necessary. Although this is a good start, I want my editor to do more. When I add braces around a code, or when I make a one-line statement, a multi-line one, I want the editor to reformat my file to properly indent it.

Emacs offers a mode called ~electric-indent-mode~ where the ultimate goal, is to achieve exactly what I described, but unfortunately, the current state of the mode is falling short of it.

The solution I found, is an external package called [[https://github.com/Malabarba/aggressive-indent-mode][~aggressive-indent~]] that re-indent the entire file on every change.

It is a bit too aggressive, but so far is working just fine for me, so let's add it to our packages:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! aggressive-indent)
#+end_src

A point to note is where to use this package. I need it on ~prog-mode~, but due to some particularities of certain languages (did someone said Python here?), I need to specify the set of languages I want to support aggressive indent. The reader can check the list of supported language on the following code snippet:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! aggressive-indent
  :hook ((emacs-lisp-mode
          c-mode
          cpp-mode
          rust-mode
          go-mode
          java-mode
          kotlin-mode
          ruby-mode
          shell-mode
          javascript-mode
          typescript-mode) . aggressive-indent-mode))
#+end_src

The reason to not include Python on this list, is the fact that Python uses indentation as block delimiter, and the package does not know how where a block ends, and a new one starts, causing re-indentation to pretty much break the code.

** Smart backspace
As part of my day job, I had to do a lot of Android development, and inevitably I used [[https://www.jetbrains.com/][JetBrains]]
IDE [[https://www.jetbrains.com/idea/][IntelliJ IDEA]]. I bring this up not to chastise who uses or to complain about it. In face, IntelliJ the best IDE for Java and Kotlin out there. It has some features that are so good, that I want to implement on any text editor I use. One of these features is what I call /Smart Backspace/.

On both, Doom and IntelliJ, when you type an open pair, the editor completes with the closing one:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

Also, when you press =<ENTER>=, the editor position the cursor on a newly inserted line, on using the correct indentation, and it also inserts a '=\n=' character after cursor. The result of these actions would be like this:

#+begin_src kotlin :tangle no
fun foo() {
    |
}
#+end_src

The difference between both editors happens when you press =<BACKSPACE>= at this point. While in Doom, this operation would result in:

#+begin_src kotlin :tangle no
fun foo() {
|
}
#+end_src

On IntelliJ, it results in:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

But what happened here?

IntelliJ was able to figure out that, since I was on the indent column of the line *and* I haven't typed anything after the auto-pair, when I pressed =<BACKSPACE>=, my intention was to get back to the state I was before pressing =<ENTER>=, therefore the name I gave to this feature: /Smart backspace/.

To achieve the same result with Doom, we have to add a function advice to delete advice Doom adds to Emacs (the ~+default--delete-backward-char-a~ advice is what is responsible to balance the blank characters you enter after a pair completion).

Our advice function checks if our cursor is position on the expected position to revert the =<ENTER>= pressed between the two pairs. If it is, we remove all the characters before the cursor on the current line. This will put the cursor on a position that Doom's advice function can remove the two new line characters around the cursor, putting the buffer on the same state we were before we pressed =<ENTER>=:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-super-backward-delete-a (&rest _)
  "Special function to super-delete things.

If the line content before cursor contains only blank characters, this function
will delete all the blank characters, and then, join with the previous line. I
there is any non-blank character before cursor, this function will delete the
entire line, but keep the correct indentation on it."
  :before '+default--delete-backward-char-a
  (let* ((line-pos (- (point) (point-at-bol)))
         (prev-indent (save-excursion
                        (forward-line -1)
                        (current-indentation)))
         (prev-line-bol (point-at-bol 0))
         (next-line-eol (point-at-eol 2))
         (smart-bs-p (or (save-excursion
                           (and (re-search-backward "{[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*}" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "\\[[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*\\]" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "([ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*)" next-line-eol t))))))
    (when (and smart-bs-p
               (<= line-pos (+ prev-indent standard-indent)))
      (delete-char (- line-pos)))))
#+end_src

Adding this advice as an /autoload/ function on our configuration is all we need to get the functionality working. When Doom loads the ~smartparens~ on the default module, it replaces the Emacs ~delete-backward-char~ function with its ~+default--delete-backward-char-a~ advice, which will load our function, which, in turn, installs itself as a =:before= advice on Doom's function.

** Balanced pairs
In most editors (as far as editors go, I only saw Emacs allowing balanced pairs), there is no balanced pair protection. If you remove a line where a closing character is, without removing its open pair, your buffer becomes unbalanced.

Emacs has some packages that help you keep the balance on pair characters, even if you try to remove a line containing just one of the pairs.

Among the packages I checked, the two top two contenders for me are [[https://github.com/noctuid/lispyville][~lispville~]] and [[https://github.com/Fuco1/smartparens][~smartparens~]]  + ([[https://github.com/luxbock/evil-cleverparens][~evil-cleverparens~]] or [[https://github.com/expez/evil-smartparens][~evil-smartparens~]]).

From the two, ~lispville~ seams to be the most maintained, but it depends on ~lispy~ and even though you can use it just for the balance protection, it requires much more code and effort to do it right, so my choice is ~smartparens~ + ~evil-cleverparens~. I tried ~evil-smartparens~ before, and it is not as polished as ~evil-cleverparens~.

To install them, make sure ~smartparens~ is enable in your =init.el=:

#+caption: $DOOMDIR/init.el
#+begin_src emacs-lisp :tangle no
  :config
  (default
      +bindings
      +smartparens)
#+end_src

And ~evil-cleverparens~ is on the =packages.el= file as well:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-cleverparens)
#+end_src

These changes will make Doom download them into its local cache when you run =doom sync=.

Before I configure these packages, I would like to explain why I turn on balance protection only on Emacs modes deriving from ~prog-mode~.

The simplest explanation is that you don't really need pair balance protection in any other place then your coding buffers. I did some informal experiments on this area, and found that pair protection turned on when you write prose is magnitudes more annoying than useful, so I will stick with protection only in ~prog-mode~.

To make Emacs turn ~smartparens~ and related packages correctly, make sure that you turn on ~evil-cleverparens-mode~ on the ~smartparens-enabled-hook~, and only enable the strict mode when editing a ~prog-mode~ buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! smartparens
  :init (add-hook 'smartparens-strict-mode-hook #'evil-cleverparens-mode)
  :hook ((prog-mode . smartparens-strict-mode)))
#+end_src

Doom will turn on ~smartparens~ appropriately, so we don't need to hook anything else to get this feature working, but there is one more configuration that I like to have on, all the time. It is the ability of Emacs to highlight the /other pair/ when the cursor is on top of a character pair.

To do so, enable the ~show-smartparens-global-mode~ after enabling ~smartparens~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! smartparens
  (show-smartparens-global-mode 1))
#+end_src

** Rich keybindings
The good thing about this feature is that Emacs already covers almost all of my [[Rich keybindings][requirements]] for free, and doom ships with a package that covers the rest of it (~which-key~). What I need to do here, is to tweak ~which-key~ to /look/ and /feel/ like I want it.

One aspect of which key that bothered me is not so much a ~which-key~ thing, and more an Emacs thing in general. This aspect is how popup windows show and hide. When Emacs shows one at the bottom of the screen, it shifts the window I'm working on upwards, and although this came to be the expected behavior, it disrupts my flow, specially if the time I take to finish a shortcut sequence is couple milliseconds more than the ~which-key~ timeout.

To remediate this situation, I found this package called  [[https://github.com/yanghaoxie/which-key-posframe][~which-key-posframe~]] that display the shortcut hints on a child frame. With a configuration or two, I believe this package can deliver what I want.

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! which-key-posframe)
#+end_src

The main adjustments I want to do, is to make sure the child frame /width/ is big enough to fit the biggest description I can have.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! which-key-posframe
  :hook (which-key-mode . which-key-posframe-mode)
  :custom
  (which-key-posframe-poshandler 'my-posframe-poshandler-frame-right-middle)
  (which-key-posframe-parameters '((min-width . 44))))
#+end_src

And respect the border color for popups:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  `(which-key-posframe-border :background "#000000")
  `(which-key-posframe :background "#21242b"))
#+end_src

I need also to set the ~which-key-posframe-poshandler~ variable, to allow a special behavior regarding positioning the child frame on the screen.

This special behavior is simply to most of the time, show the shortcut hints on the right side of the frame, but if I invoke an Embark action, I want the shortcut hints child frame to show up right besides the cursor point.

To achieve this behavior, I'll define a =nil= placeholder variable that I can set to =t= when invoking Embark.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defvar my-which-key-on-embark nil)
#+end_src

Which such variable created, I can define my function to place the frame where I want it:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-posframe-poshandler-frame-right-middle (info)
  "Posframe's position handler.

Get a position which let posframe stay vertically centralized onto current
frame's right site. Checkk the docstring of `posframe-show' for more information
about the INFO structure."
  (if my-which-key-on-embark
      (posframe-poshandler-point-bottom-left-corner info)
    (let* ((frame-width (plist-get info :parent-frame-width))
           (frame-height (plist-get info :parent-frame-height))
           (posframe-width (plist-get info :posframe-width))
           (posframe-height (plist-get info :posframe-height)))
      (cons (- frame-width posframe-width (line-pixel-height))
            (/ (- frame-height posframe-height) 2)))))
#+end_src

In order to connect ~embark~ to ~which-key~, I need to advise the function I defined to invoke ~which-key~ when I invoke ~embark~:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-embark-which-key-action-wrapper (orig-fun &rest args)
  "Wrap ORIGIN-FUN on a let bind to indicate this is an Embark call.

It passes ARGS to ORIGIN-FUN without altering them. "
  :around 'my-embark-which-key-action-indicator
  (let ((my-which-key-on-embark t))
    (apply orig-fun args)))
#+end_src

With the ~which-key-posframe~ configured, I just need to do some minor adjustments on the ~which-key~ package to make it display the hints on a single column with a single description occupying up to 40 characters of such column:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! which-key
  (setq which-key-allow-multiple-replacements t)
  (setq which-key-min-display-lines 10)
  (setq which-key-max-display-columns 1)
  (setq which-key-add-column-padding 2)
  (setq which-key-max-description-length 40))
#+end_src

** Useful line numbers
A long time ago, I read on some Vim mailing list, an opinion on how line numbers should behave on different editing modes (if you know who is the original author of such idea, please let me know, so I can give credit where credit is due). Since on normal mode is pretty useful to know the line count from the cursor until some target text, it makes more sense to have the =relative number= shown on the gutter, but when I'm editing the buffer, is nice to have a sense of size by looking to the line numbers.

So, I can describe this behavior as follows:

- When on normal mode, show relative line numbers;
- When on insert mode, show absolute line numbers;

To achieve this, I need a function that turns the /absolute/ line number when line numbers are visible:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-absolute-h ()
  "If line numbers are visible, set the current line number type to `absolute.'"
  (if display-line-numbers
      (setq display-line-numbers t)))
#+end_src

And another function to put the line numbers on /relative mode/ (but again, only if line numbers are visible):

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-visual-h ()
  "If line numbers are visible, set the current line number type to `visual'"
  (if display-line-numbers
      (setq display-line-numbers 'visual)))
#+end_src

With those functions created, after loading Evil, I can hook them to a mode switch:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook! '(evil-emacs-state-entry-hook
               evil-insert-state-entry-hook) 'my-line-number-absolute-h)
  (add-hook! '(evil-emacs-state-exit-hook
               evil-insert-state-exit-hook) 'my-line-number-visual-h))
#+end_src

To finalize, I want to make line numbers visible on any programming mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (setq-hook! 'prog-mode-hook display-line-numbers-type 'visual))
#+end_src

** Auto-Saving
First of all, since I'm going to save my work constantly, I don't want Emacs to ask me if it should really exit, or if it should kill outstanding processes while doing it. For me, if I'm telling Emacs to quit, I want it to do it, regardless its state, but I don't want to lose any content of my current work. So, the first thing I'm going to do, is to disable questions when I'm quitting Emacs:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)
#+end_src

Emacs allows you to define some /advices/ to any function you want. This allows you to hook some code when the user, or the system calls such functions. On the case of aggressive auto-save, I want Emacs to save any content when I try to close the buffer associated with the content, of if I'm trying to quit Emacs. To do so, I'll create an /autoload/ advice to perform such work:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-save-all-buffers-a (&rest _)
  "Advice to run `save-some-buffers' before a function.

This is a part of the full auto-save feature."
  :before (list #'save-buffers-kill-emacs #'my-tabs-close-buffer-tab)
  (save-some-buffers t nil))
#+end_src

And to wrap up this configuration, I enable the auto-save mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(auto-save-visited-mode 1)
#+end_src

Call the same advice as a normal function when Emacs executes the auto-save hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! 'auto-save-hook #'my-save-all-buffers-a)
#+end_src

And add the advice function to the ~after-focus-change-function~ as well, just to make sure Emacs save any outstanding buffer as soon as possible if it loses focus:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-function :after after-focus-change-function #'my-save-all-buffers-a)
#+end_src

This aggressive auto-save will work as expected, but it will crate a side effect with my literate configuration. Since Doom tangles the Org file every time we save it, the aggressive auto-save will make this tangle happen more often than we want.

Doom documentation offers a partial solution to this problem asking us to remove the auto-tangle function from the save hook, so let's do it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'org-mode-hook #'+literate-enable-recompile-h)
#+end_src

Another core behavior that does not play well with my aggressive auto-save configuration is how Doom configures ~ws-butler~. While I understand the rationale behind the choice of always remove blank spaces regardless the cursor position, I rather the plugin to not remove blank spaces before the cursor.

To adjust that, let's make ~ws-butler~ behave how I expect it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! ws-butler
  (setq ws-butler-keep-whitespace-before-point t))
#+end_src

** Persist frame position and geometry
Before I start tackling my own requirement, let's make Emacs /remember/ its window size and position between launches.

First, I like to define an autoloaded function to hook into the Emacs kill process to save frame dimensions. The reason to get an autoload function, is to allow Emacs to *not* load it until it really needs it, which would be when I'm quitting Emacs.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-save-frame-dimensions-h ()
  "Caches the current frame dimensions and position."
  (if-let ((main-frame (car-safe (visible-frame-list))))
      (doom-store-put 'last-frame-size
                      (list (frame-position main-frame)
                            (frame-width main-frame)
                            (frame-height main-frame)
                            (frame-parameter main-frame 'fullscreen)))))
#+end_src

Then, I like to have the analog function to call when we create a frame:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-restore-frame-dimensions-h ()
  "Restore frame dimensions and position from `my-save-frame-dimensions-h'."
  (if-let (dims (doom-store-get 'last-frame-size "default"))
      (cl-destructuring-bind ((left . top) width height fullscreen) dims
        (setq initial-frame-alist
              (append initial-frame-alist
                      `((left . ,left)
                        (top . ,top)
                        (width . ,width)
                        (height . ,height)
                        (fullscreen . ,fullscreen)))))
    (add-to-list 'default-frame-alist '(height . 40))
    (add-to-list 'default-frame-alist '(width . 140))))
#+end_src

With the function defined, I just need to connect them to the correct hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-emacs-hook #'my-save-frame-dimensions-h)
(my-restore-frame-dimensions-h)
#+end_src

** TODO Remote editing
TBD (still need to figure out the best way to address this).

* Personal preferences
This section will show the reader, some of the small changes I decided to implement on Doom related to Evil, my personal keybindings, my choice of appearance, and other personal configurations. All in all, is pretty safe to skip this section if you intend to implement your own customization.

** Evil
For most of it, Doom integration of Evil is pretty amazing, I found just one package I don't use (or don't want to use at all), two configurations that I want to do some adjustments, and three packages missing.

The package I don't use is ~evil-escape~, and its purpose, is to allow one to type =j k= fast enough on insert mode to force moving from insert mode to normal mode.

If you're used to this feature, good for you, but I was never able to adjust my muscle memory to it, so I rather disable it on =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

The first Evil configuration I want to adjust to my liking is on ~evil-goggles~. I understand Henrik (Doom's creator) has a good rational on why he set up ~evil-goggles~ the way it is, but I like the original design where *all* changes get the highlight treatment.

Also, I use ~evil-cleverparens~, and its editing operations are not configured on ~evil-goggles~, so, in order to make it work for me, I have to do two things:

1. Re-enable the change feedback disabled by default on Doom;
2. Add all ~evil-cleverparens~ commands to the ~evil-goggles--commands~ to allow ~evil-goggles~ to handle changes from those commands as well.

I can perform those changes using ~use-package~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-goggles
  :hook (doom-first-input . evil-goggles-mode)
  :config
  (setq evil-goggles-duration 0.15
        evil-goggles-enable-delete t
        evil-goggles-enable-change t)

  (pushnew! evil-goggles--commands
            '(evil-cp-delete
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-line
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--delete-line-advice)
            '(evil-cp-delete-sexp
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-enclosing
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-yank
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-line
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-sexp
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-enclosing
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-change
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-line
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-sexp
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-enclosing
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-paste-after
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)
            '(evil-cp-copy-paste-form
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)))
#+end_src

After this I can sneak a quick modification to allow ~evil-goggles~ to use the same faces used on =diff=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil-goggles
  (evil-goggles-use-diff-refine-faces))
#+end_src

The second configuration is regarding centralizing the cursor after search jumps. I find myself pretty uncomfortable after I press =n= following a search term, and I figured it out that what makes me uncomfortable is the fact the cursor is at the bottom of the screen, and I have almost no visibility of the text after it.

To fix this, I will add an advice after the Evil search function used to perform those jumps, to recenter the cursor on the window:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-center-after-jump-a (&rest _)
  :after 'evil-ex-search
  (evil-scroll-line-to-center nil))
#+end_src

And to make this behavior more consistent throughout the editor, I will add the same function used to advise ~'evil-ex-search~ as a hook to the ~evil-jumps-post-jump-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook 'evil-jumps-post-jump-hook #'my-center-after-jump-a))
#+end_src

And finally, for the packages I'm missing, they are:

- ~evil-matchit~
- ~plus-minus~
- ~evil-string-inflection~

*** Evil-MatchIt
In all fairness, ~matchit~ (the one originally from Vim) is also disabled by default, but it provides such useful feature that I can't understand why it is not part of the standard Vim/Evil.

To the reader not familiar with this plugin, let me give a brief overview of it. You probably know that pressing the key =%= on a pair of character (e.g. =(=, =)=, =[=, =]=, etc.), makes the cursor jump to the other pair.

The ~matchit~ plugin, extends this functionality to other types of pairs, like XML/HTML tags, language control flows like =if=, =else=, and =endif=, and others. So, as I said, a pretty useful plugin!

Since [[https://github.com/redguardtoo/evil-matchit][~evil-matchit~]] is not distributed with Doom, I need to bring its package in:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-matchit)
#+end_src

Then, need to make sure to enable the plugin itself. In order to not slow the Emacs startup, I will enable it after I load the first file into a buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-matchit
  :hook (doom-first-file . global-evil-matchit-mode)
  :init
  (setq evilmi-quote-chars (string-to-list "'\"/")))
#+end_src

*** Plus-Minus
[[https://github.com/peterwu/plus-minus][~plus-minus~]] is a package that provides the functionality to increase or decrease a number value at point. On Vim, the key bindings for these actions are =C-a= and =C-x= respectively.

I spend too much time thinking that I should preserve the =C-x= keybinding for Emacs' sake, and I learn to use a command or two that uses it, but the reality is that I don't really need it, so I will give it a try on rebinding this key to its original Vim purpose, but instead of using ~evil-numbers~ (which Doom provides as a core package), I'll try a brand-new package called ~plus-minus~:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-numbers :disable t)

(package! plus-minus
  :recipe (:host github
           :repo "peterwu/plus-minus"))
#+end_src

Since this package provides the correct ~autoloads~ on it, I can simply configure it to get deferred until I actually need it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! plus-minus :defer t)
#+end_src

Before defining the keybindings for this I would like to have an extra behavior when I try to increase or decrease a number at point. I would like to rotate the text at point with the same keybinding if the /thing at point/ is not a number.

Doom ships with the ~rotate-text~ package by default, but I need couple helper functions to define which package should handle the key press:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-inc-or-rotate-at-point (arg)
  "Try to rotate or increase the text at point.

If the thing under cursor is not rotated, tries to increase the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward+) (+/-:forward+))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward+) (+/-:forward+))))))
#+end_src

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-dec-or-rotate-at-point (arg)
  "Try to rotate or decrease the text at point.

If the thing under cursor is not rotated, tries to decrease the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))))))
#+end_src

And I also like to define some extra words for rotation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! rotate-text
  (add-to-list 'rotate-text-words '("yes" "no"))
  (add-to-list 'rotate-text-words '("allow" "deny"))
  (add-to-list 'rotate-text-words '("allowed" "denyed")))
#+end_src

With all in place, we just need to define the keybindings:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :n "C-a" #'my-inc-or-rotate-at-point
  :n "C-x" #'my-dec-or-rotate-at-point
  (:prefix "g"
    :desc "Inc sequence" :v "=" #'+/-:block+
    :desc "Dec sequence" :v "-" #'+/-:block-
    :desc "Inc sequence" :n "=" #'my-inc-or-rotate-at-point
    :desc "Dec sequence" :v "-" #'my-dec-or-rotate-at-point)
  (:leader
   :desc "Emacs C-x" :n "C-x" ctl-x-map))
#+end_src

In order to allow me to repeat the last increase or decrease, I will define a /repeatable map/ for my custom increase and decrease functions:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-inc-or-rotate-repeat-map
                '((my-inc-or-rotate-at-point . "=")
                  (my-dec-or-rotate-at-point . "-"))
                "Keymap to repeat the last number increase or decrease.")
#+end_src

*** Evil-String-Inflection
I've been on situations where I realized that I used /camelCase/ for all my variables, where the standard coding style of the language, request to use /snake_case/ style. There are packages available, that allow you to cycle through all case styles on a given word.

I found the [[https://github.com/akicho8/string-inflection][~string-inflection~]] package to be one of the best available. There is the package [[https://github.com/ninrod/evil-string-inflection][~evil-string-inflection~ ]]to integrate with Evil, but it turns out to not work as expected, so I will have to configure Evil integration myself. Let's start with the package itself:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection)
#+end_src

As with the ~matchit~ package, I'll defer its loading until we need it, but different from ~matchit~, I have to defer it using an alternative approach. I will make the package load on the first invocation of one of its main commands:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase))
#+end_src

I want to have a rich set of mappings for this package, so I will add one key for each inflection plus a toggle and a cycle:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("g~" . "string inflection")
      :desc "cycle" "~" #'string-inflection-all-cycle
      :desc "toggle" "t" #'string-inflection-toggle
      :desc "CamelCase" "c" #'string-inflection-camelcase
      :desc "downCase" "d" #'string-inflection-lower-camelcase
      :desc "kebab-case" "k" #'string-inflection-kebab-case
      :desc "under_score" "_" #'string-inflection-underscore
      :desc "Upper_Score" "u" #'string-inflection-capital-underscore
      :desc "UP_CASE" "U" #'string-inflection-upcase)
#+end_src

In order to create a nicer workflow, I want to access the previous shortcuts by pressing the same key after the initial inflection. For instance, I want to press =SPC g ~= to start the inflection, and keep pressing just =~= to cycle through all the other inflections.

To achieve this behavior I will use the ~my-repeat-map!~ macro introduced on the section [[Repeatable commands]]:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-string-inflection-repeat-map
                '((string-inflection-all-cycle . "~")
                  (string-inflection-toggle . "t")
                  (string-inflection-camelcase . "c")
                  (string-inflection-lower-camelcase . "d")
                  (string-inflection-kebab-case . "k")
                  (string-inflection-underscore . "_")
                  (string-inflection-capital-underscore . "u")
                  (string-inflection-upcase . "U"))
                "Keymap to repease the last string inflection.")
#+end_src

To make ~string-inflection~ to work nice with Evil, I will create an /Evil operator/ to allow me to change the string inflection of a target text object:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (evil-define-operator my-evil-operator-string-inflection (beg end _type)
    "Define a new evil operator that cicles underscore -> UPCASE -> CamelCase."
    :move-point nil
    (interactive "<R>")
    (string-inflection-all-cycle)
    (setq evil-repeat-info (list [?g ?~])))

  (define-key evil-normal-state-map (kbd "g~") 'my-evil-operator-string-inflection))
#+end_src

** Keybindings
Since I decided to write this configuration, I also decided to try to use the standard Doom key bindings as much as possible, and for the most part of it, I'm not having as much problem as I expected. There are three main areas where I still like to define my own bindings.

*** Window navigation
A while ago, I configured Vim to move the cursor from one window to another using the standard movements keys (=h=, =j=, =k=, and =l=) while keeping =Ctrl= pressed. I got so used to these shortcuts, that I can't live without it anymore.

The good news is that, on most cases, there is no conflict between features I use and these shortcuts, and on the cases that a conflict exists, there are reasonable options to work around these limitations.

The first step to achieve a global window navigation shortcuts, is to clean the target keys from any keymap that might bind them to a command:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after outline
  (:map outline-mode-map
   :gn "C-h" nil
   :gn "C-j" nil
   :gn "C-k" nil
   :gn "C-l" nil)))
#+end_src

After that, I can bind these keys to the target window movements to the proper window commands:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :gn "C-h" #'evil-window-left
  :gn "C-j" #'evil-window-down
  :gn "C-k" #'evil-window-up
  :gn "C-l" #'evil-window-right)
#+end_src

Some other modes don't play nice with this particular key bindings I choose, and I have to adjust them accordingly. This is the case of the =Info-mode=, where =C-j= and =C-k= are the keys to navigate forward and backwards on nodes. The solution for me is to bind those commands to other keys, and configure the proper window navigation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after info
      :map Info-mode-map
      :gn "s-k" #'Info-backward-node
      :gn "s-j" #'Info-forward-node
      :gn "C-k" #'evil-window-up
      :gn "C-j" #'evil-window-down)
#+end_src

*** Vim defaults
Here I need to make yet another disclaimer to the reader: I know what I'm about to write is a pet peeve, and most likely most Doom users won't even understand this, but...

On Doom, there are these keymaps bound to =<leader> w ...=, that should match Vim's =<C-w> <C-...>=. Since the /leader shortcuts/ are more ergonomic for me, I got used to them quickly. The problem I have, is the difference between =<C-w> <C-o>= and =<leader> w o=!

To not lose a Doom-only keymap, instead of simply rebinding =<leader> w o= to the /correct/ command, I'll /move/ ~doom/window-enlargen~ to a different keymap (=<leader> w z= to represent /zoom window/), and assign the /correct/ command to the /correct/ keymap:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("w" . "window")
      :desc "Enlarge window"         :n "z" #'doom/window-enlargen
      :desc "Select window"          :n "o" #'delete-other-windows)
#+end_src

*** Personal shortcuts
Key bindings in this section are purely personal choice. Feel free to give them a try if you want, but if you're used to Doom Emacs already, my suggestion is to skip this section.

#+begin_center
◆
#+end_center

The first keymap group I like to add custom shortcuts is the multiple cursors. When I first heard about multiple cursors, was on a demo of the [[https://macromates.com/][TextMate]] editor. I got so impressed by it that this feature was one of the first things I would search on an editor. Fast forwarding to January 2008, I was watching yet another demo of a brand-new editor, when the person showing off the features, demonstrated the multiple cursors. This editor was [[https://www.sublimetext.com][Sublime Text]], and I couldn't resist the chance to give it a try. For reasons of the brain (at least my brain), the shortcuts defined to manipulate multiple cursors got engraved in my memory, and recently, I decide to stop fighting against it and embrace! So these are the shortcuts (which might be different from the current shortcuts in Sublime) that I got /used to/:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 :gn "s-d" #'evil-mc-make-and-goto-next-match
 :gn "s-u" #'evil-mc-skip-and-goto-prev-cursor
 :gn "s-n" #'evil-mc-skip-and-goto-next-match
 :gn "s-g" #'evil-mc-make-all-cursors
 :gn "C-M-k" #'evil-mc-make-cursor-move-prev-line
 :gn "C-M-j" #'evil-mc-make-cursor-move-next-line)
#+end_src

#+begin_center
◆
#+end_center

Another /nice to have/ binding I got used to, is to move blocks of text up and down, using =j= and =k=, plus the =Meta= (a.k.a. =Alt=, =option=, or  =⌥=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :nvi "M-j" #'drag-stuff-down
      :nvi "M-k" #'drag-stuff-up)
#+end_src

#+begin_center
◆
#+end_center

Something that I really like but usually forget to use is the ability to insert a new line while on /insert mode/, above or below the current line, regardless where the cursor is. To use it, I would simply press =<ENTER>= with =<SUPER>= (a.k.a. =cmd= or =⌘=) to insert a line bellow, or =<ENTER>= plus =<SHIFT>= and =<SUPER>= for a line above:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :i [s-return]   #'+default/newline-below
      :i [s-S-return] #'+default/newline-above
      (:when IS-MAC
         :gn "s-RET"        nil
         :gn [s-return]     nil
         :gn "S-s-RET"      nil
         :gn [S-s-return]   nil))
#+end_src

#+begin_center
◆
#+end_center

Doom Emacs, offer a shortcut to bring back the last dismissed popup, which is what I want to do on the majority of the cases. But sometimes, I want to bring back a specific popup buffer to the front, and I like to have a dedicated prefix key to handle this scenario.

For now, I set a shortcut for the =*Messages*=, and the =*Backtrace*= buffers, but more popup buffer might get added here in the future:

#+caption:config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("v" . "view")
      :desc "View Messages" :n "m" #'(lambda ()
                                       (interactive)
                                       (pop-to-buffer "*Messages*")
                                        (goto-char (point-max)))
      :desc "View Backtrace" :n "e" #'(lambda ()
                                        (interactive)
                                        (pop-to-buffer "*Backtrace*")))
#+end_src

As you can see, I also like to /scroll to the bottom/ of the buffer when opening messages. The rationale behind it is the fact that if I want to quick loo into the =*Messages*= buffer, is most likely to check the latest messages there.

Also, for the =*Messages*= buffer, I like to be able to press =q= to quit as well. Unfortunately this is not defined by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map messages-buffer-mode-map
      :n "q" #'delete-window)
#+end_src

#+begin_center
◆
#+end_center

One binding I feel is missing on Doom, is the ability to evaluate any sexp on *any* mode, like a /global/ ~eval-last-sexp~. Gladly, it's easy enough to create my own:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :prefix "g"
      :desc "Eval last sexp" :n ")" #'eval-last-sexp)
#+end_src

#+begin_center
◆
#+end_center

I don't remember when this shortcut entered my life, but some time ago I got used to using =s-RET= to /confirm operations/ like sending emails and messages. In order to try to replicate this behavior I will start setting it to the ~with-editor-mode-map~ together with the analog cancel operation with =s-ESC= shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map with-editor-mode-map
      :in [s-return] #'with-editor-finish
      :in [s-escape] #'with-editor-cancel)
#+end_src

#+begin_center
◆
#+end_center

Doom ships with the /Rainbow Mode/ package, which is a package that colorizes strings that represent colors. Usually there is no need to enable this mode globally because the colorization might get in the way of legibility, but on the cases where it is useful (e.g. editing CSS or Android XML files), it is *really* useful.

Because of this, I want to set this mode as a toggable shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("t" . "toggle")
      :desc "Rainbow mode" :mvn "R" #'rainbow-mode)
#+end_src

*** Repeatable shortcuts
Due to the nature of modal edit, some shortcuts need more than one key press to activate. This is usually fine until we try an action designed to repeat (e.g. side scroll and window resizing). This section will use the ~my-repeat-map!~ macro defined on the [[Repeatable commands]] sections to make these actions more ergonomic.

#+begin_center
◆
#+end_center

The first candidate for a repeatable pattern is window resizing. On Vim (and also Evil) for instance, the key binding to increase height is =C-w +=. Doom makes this a little bit better by making all key bindings from =C-w= accessible with the prefix =SPC w=, but still, adjusting the size of a window with multiple keystrokes like this, is a bad experience.

We can make the window resizing commands safe to repeat, which would allow us to repeat the last resizing with the =.= repeat operator. The problem with this approach, is the fact that we can /change directions/ when repeating the resize. For instance, if we are increasing the height of a window, and we press the =.= couple more times we wanted, to decrease its size, we would have to start over with the decrease command and pay attention to not get it wrong this time.

To avoid this issue, I will define a /repeatable map/ for resizing, and because this is a separate map from the normal window map, I can add couple extra keys there to make the operation even smoother, for instance, we can increase the window height with =+= or with the === key

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-window-resize-repeat-map
                '((evil-window-increase-height . "+")
                  (evil-window-increase-height . "=")
                  (evil-window-decrease-height . "-")
                  (evil-window-decrease-height . "_")
                  (evil-window-increase-width . ">")
                  (evil-window-decrease-width . "<"))
                "Repeatable map for window resizing")
#+end_src

#+begin_center
◆
#+end_center

Sometimes you're editing a buffer on a window that requires you to scroll to the right and left to read its content. You can achieve that by pressing =z l= to scroll to the right, and =z h= to scroll to the left. While this is ok, besides enabling to repeat this motion with just an =l= or an =h= after the initial scroll, I also want to jump longer distances (the default is to move one character on each =z l= or =z h= shortcuts). To jump more than one character, I need to create a wrapper function that passes a bigger number to the ~evil-scroll-column-right~ or ~evil-scroll-column-left~ functions:

#+caption: autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-big-scroll-column-right ()
  "Wrapper for the `evil-scroll-column-right' that passes 10 as the jump size."
  (interactive)
  (evil-scroll-column-right 10))

;;;###autoload
(defun my-big-scroll-column-left ()
  "Wrapper for the `evil-scroll-column-left' that passes 10 as the jump size."
  (interactive)
  (evil-scroll-column-left 10))
#+end_src

And with those helper functions I can define the proper /repeatable map/ for side scrolling:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-side-scrolling-repeat-map
                '((evil-scroll-column-right . "l")
                  (my-big-scroll-column-right . "L")
                  (evil-scroll-column-left . "h")
                  (my-big-scroll-column-left . "H"))
                "Repeatable map to scroll the buffer left or right.")
#+end_src

** Appearances
As far as I understand, there is a share of Emacs users that value Emacs functionalities over its looks, and I would like to write something targeted for those users.

You are awesome! I can't imagine how liberating it would feel if my brain did not obsess about my editor's appearance, so, stay strong folks! The breakthroughs on technology happen more often by the desire of people like you then people like me.

With that out of the way, I need to explain to the reader my personal position on this subject. As a person with [[https://en.wikipedia.org/wiki/Attention_deficit_hyperactivity_disorder][ADHD]] and [[https://en.wikipedia.org/wiki/Obsessive%E2%80%93compulsive_disorder][OCD]].

Look, mate. There is not much else to say, but if you need a bit more let me say this: When your brain is constantly searching for dopamine, and is incapable to retain it for much longer, every tinny rewarding counts towards the goal to keep my focus on one subject. If my work environment is pleasing to look, there is a lower chance my brain gets distracted by the scene outside the window. If I open my editor and get the feeling of /"oh yeah"/, then my brain will look forward to using the same tool again, or as I saw on this [[https://twitter.com/ADHDelaide/status/1326412306079682560][tweet]] a while ago, and reproduce it here for you:

#+begin_quote
❝ Having *ADHD* is basically finding new ways to trick your brain into doing the stuff you want it to do, until you die. ❞
─ *@ADHDelaide*
#+end_quote

Nevertheless, keep in mind that taste, is a personal thing. What I consider to be beautiful, might look horrendous to the reader, and that is OK.

So, if you're happy with the look and feel of your editor, feel free to skip this entire section.

*** Frame

The Emacs frame is the container for my small world, and although I intend to do most of my things within Emacs, I still want it to look like it belongs to its environment (macOS in my case), and there are couple things I like to change to make it more macOS.

The first one is to remove the text from the title bar. On macOS, the application name is present on the system menu, so there is no reason to keep any text on the title bar:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq frame-title-format nil
      ns-use-proxy-icon nil)
#+end_src

And the second one, is to make the title bar to have the same color as the background of my selected theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

*** Editor

The first thing to do to help with my editor appearance, is to store the current line height in a variable. This way, other adjustments can use this value without worrying about different font sizes:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defvar my-line-pixel-height (line-pixel-height)
  "Line height in pixels.

Used to avoid getting the wrong line height when `text-scale-mode' is active.")
#+end_src

One editor visual I like to have while I'm coding, is the ~fill-column-indicator~. Unfortunately I discovered that on macOS, the default ~fill-column-indicator~ face, can't render Unicode characters properly. The workaround here is to make this particular face to use a font that can render them:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-face-attribute 'fill-column-indicator nil
                    :font "Arial Unicode MS"
                    :height 140
                    :foreground (doom-color 'base3 256))
#+end_src

Using /Arial Unicode MS/ allow me to use the "=┊=" character to decorate my ~prog-mode~ buffers. After setting this up, I need to adjust the ~fill-column~ value to the column I want (while is usually 100), and make the column indicator use the correct Unicode character (which is =0x9482=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default fill-column 100
              display-fill-column-indicator-column 100
              display-fill-column-indicator-character 9482)
#+end_src

After this configuration I want to make sure the column indicator is off by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(global-hl-line-mode -1)
#+end_src

And enabled on all ~prog-mode~ buffers:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
#+end_src

#+begin_center
◆
#+end_center

As with column indicator, there is another visual that I consider crucial for programming, but a bit annoying when writing prose: The current line highlight.

I can't imagine coding without it, but when I'm writing, it becomes more a distraction then an aid.

On Doom, to make sure current line highlight gets disabled, you need to remove its global mode from the ~doom-first-buffer-hook~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Then, I can add the mode to all ~prog-mode~ buffers with another hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+end_src

#+begin_center
◆
#+end_center

Another extra for the editor visuals is rendering the character =^L=, which represents a page break (more precisely, the /form feed/ character).

The page break character is considered a /space/ or /empty/ character, which allows one to add it on a coding file without breaking the build for such file.

There are a couple packages that achieve this goal, but I set on the [[https://github.com/purcell/page-break-lines][~page-break-lines~]] from [[https://github.com/purcell][Steve Purcell]] because he chose to implement this feature using glyph composition instead of /font-lock/:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines)
#+end_src

There is just one configuration I prefer to change over the defaults, which is the size of the horizontal line. I like the horizontal like to stop at the ~fill-column~ column, which gives this nice /box feeling/ to the code.

Besides this change, I only enable the mode on ~prog-mode~ buffers, and I like to define a shortcut key to jump to the next or previous page break:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! page-break-lines
  :hook ((prog-mode . page-break-lines-mode))
  :init
  (setq page-break-lines-max-width fill-column)

  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

#+begin_center
◆
#+end_center

Since the time when widescreen monitors became the standard, when it comes to split windows in two, I prefer horizontal splits (one window aside of the other). In order to tell Emacs that I prefer horizontal splits, I have to set the width split threshold to a small number to add weight on Emacs' decision of which orientation to split:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq split-width-threshold 40)
#+end_src

*** Theme
I believe this section to be the most volatile section on this text. Since I got interested on cool old esoteric editors, I'm on an endless search for the Holy Grail of themes. So far I got fond of Tomorrow Night and I use it for the most part of the last 5 years. Recently I got annoyed by some color choices of the theme (the background and line highlight are a bit odd in my opinion), so I kept looking.

I decided to give /Doom-One/ a try, and so far I'm enjoying. I will admit that the purplish feeling of the palette is not my style, but overall, I'm not finding a bed choice.

So, to make /Doom-One/ the default theme, set the variable ~doom-theme~ to the symbol ='doom-one= to let Doom know what is the theme it should load:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
#+end_src

And because I like visual cues on my editor, I will turn on the ability to display *bold* and /italic/ faces for the theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-themes-enable-bold t
      doom-themes-enable-italic t)
#+end_src

*** Typography
:PROPERTIES:
:CUSTOM_ID: prefs-typography
:END:
This section requires an important disclaimer to the reader. In the majority of the cases, one should not /need/ to customize their fonts the way I'm doing it. Doom Emacs has a system to configure the editor fonts, and one should prefer to use such systems instead of this particular configuration.

Doom exposes five (optional) variables for controlling fonts:

- ~doom-font~ :: The global font used by Emacs;
- ~doom-big-font~ :: Used for ~doom-big-font-mode~, which you can use for presentations or streaming;
- ~doom-variable-pitch-font~ :: Font used for prose text (if you configure such modes to accept variable pitch fonts);
- ~doom-serif-font~ :: The default font to use for the fixed-pitch-serif face;
- ~doom-unicode-font~ :: Fallback font for Unicode glyphs;

They all accept either a font-spec, a font string (e.g. "Input Mono-12"), or a =xlfd= font string. You generally only need ~doom-font~ and ~doom-variable-pitch-font~, but I like to set ~doom-big-font~ as well, to make sure any time I switch to a presentation mode, it still feels like I have the same editor, but with a bigger font.

With that out of the way, I need to explain what is, and why my /typography/ configuration exists.

#+begin_center
◆
#+end_center

In the past years, I've got involved in some projects where I worked directly with the UX team on visual identity tasks. One of the first thing I got used to doing, is to define the typography of the project. But what is typography? According to the Wikipedia:

#+begin_quote
*Typography* is the art and technique of arranging type to make written language legible, readable and appealing when displayed.
#+end_quote

In the case of my configuration, I can define typography as a set of rules regarding displayed text that I want to use regardless the mode Emacs is in. Or simply put:

Text in my editor must be consistent, and look good.

To achieve this, I have to define said rules, and create a mechanism that will help me get the editor to behave the way I want. The one exception are the colors used on text elements. I want to let this particular trait to the theme I'm using.

The first rule to define is the simplest one: which fonts to use throughout the editor.

Currently, I narrowed my selection to these 3 fonts:

- [[https://github.com/iaolo/iA-Fonts][iA Writer Mono]] :: Used as my default monospaced font. The actual font I'm using is the [[https://www.nerdfonts.com/][Nerd Fonts]] version, known as /"iMWritingMonoS Nerd Font"/ due to its support for the ~all-the-icons~ package;
- [[https://github.com/iaolo/iA-Fonts][iA Writer Quattro]] :: Used as my default font for prose writing. For this font in particular, I can't use the Nerd Fonts version, nor the version distributed through [[https://brew.sh/][Homebrew]]. These versions, use the static version of the font that does not support different weights. For my configuration I use the [[https://github.com/iaolo/iA-Fonts/tree/master/iA%20Writer%20Quattro/Variable][Veriable]] version of the font;
- [[https://github.com/googlefonts/roboto][Roboto]] :: Used on UI elements like the project drawer, tab names, and tooltips;

To install the [[https://github.com/iaolo/iA-Fonts][iA Writer Mono]] and the [[https://github.com/googlefonts/roboto][Roboto]], one can use [[https://brew.sh/][Homebrew]] on macOS:

#+caption: Commands to install fonts with Homebrew
#+begin_src shell :tangle no
brew tap homebrew/cask-fonts
brew install --cask font-roboto font-im-writing-nerd-font
#+end_src

But for the [[https://github.com/iaolo/iA-Fonts][iA Writer Quattro]] you have to use to install it manually because the version offered by Homebrew is the static version of the font, which does not come with all the weights available. The correct font to install here is the /variable/ type.

To install the correct font, first download it using =curl=:

#+caption: Commands to download the iA Writer font
#+begin_src shell :tangle no
cd ~/Downloads && {
 curl -O 'https://github.com/iaolo/iA-Fonts/raw/master/iA%20Writer%20Quattro/Variable/iAWriterQuattroV.ttf'
 curl -O 'https://github.com/iaolo/iA-Fonts/raw/master/iA%20Writer%20Quattro/Variable/iAWriterQuattroV-Italic.ttf'
 cd -
}
#+end_src

Then, run the following AppleScript to perform the installation:

#+caption: Apple Script used to install iA Writer fonts
#+begin_src shell :tangle no
osascript <<'END'
  set theDownloadsFolder to get path to Downloads folder
  tell application "Finder"
    set allFonts to every file of theDownloadsFolder whose name starts with "iAWriterQuattroV"
  end tell

  repeat with theFont in allFonts
    tell application "Finder"
        open theFont
    end tell

    tell application "Font Book"
        activate
        set theFontWindow to the first window
    end tell

    tell application "System Events"
        tell process "Font Book"
            tell window 1
                tell group 1
                    click button "Install Font"
                end tell
            end tell
        end tell
    end tell
  end repeat
END
#+end_src

The rest of the rules are more subjective, and in all honesty, the methodology I used to decide which slant, and weight to use to each one of the text elements is non-existent. I simply tried, checked how it looked, and asked myself, /"Is this a nice looking element?"/. If the answer was yes, I kept the configuration.

For the size, I started with the headline level 1 and configure it to be as big as it could be without looking disproportional to the text. Then, I reduced the size for the next level gradually until I get to the 8^{th} one, guaranteeing that it would not be smaller than the normal font size.

In practice, this means:

#+caption: Headline sizes and multipliers
#+name: tbl:typ-heads
| Headline Level | Proportional size | Multiplier |
|----------------+-------------------+------------|
| Level 1        |              100% |        2.0 |
| Level 2        |               80% |        1.8 |
| Level 3        |               60% |        1.6 |
| Level 4        |               40% |        1.4 |
| Level 5        |               30% |        1.3 |
| Level 6        |               20% |        1.2 |
| Level 7        |               10% |        1.1 |
| Level 8        |                0% |        1.0 |

To make my typography rules easy to refer to, I create one face for each rule as follows:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defface my-default-mono `((t :font ,(font-spec :family "iMWritingMonoS Nerd Font"
                                                :size 16)))
  "Default monospaced font used on majority of the buffers."
  :group 'my-typography)

(defface my-big-face-mono `((t :font ,(font-spec :family "iMWritingMonoS Nerd Font"
                                                 :size 26)))
  "Monospaced font used on presentation mode."
  :group 'my-typography)

(defface my-default-ui `((t :font ,(font-spec :family "Roboto"
                                              :size 16)))
  "Extra face used on UI elements."
  :group 'my-typography)

(defface my-ui-window-header `((t :inherit my-default-ui
                                  :height 0.8))
  "Face used on decorative buffer headers."
  :group 'my-typography)

(defface my-default-prose `((t :font ,(font-spec :family "iA Writer Quattro V"
                                                 :size 18)))
  "Default variable pitch font used on prose writing."
  :group 'my-typography)

(defface my-document-title `((t :inherit my-default-prose
                                :height 2.4
                                :weight light
                                :slant normal))
  "Face used for document titles."
  :group 'my-typography)

(defface my-headline-1 `((t :inherit my-default-prose
                            :height 2.0
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-2 `((t :inherit my-default-prose
                            :height 1.8
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-3 `((t :inherit my-default-prose
                            :height 1.6
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-4 `((t :inherit my-default-prose
                            :height 1.4
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-5 `((t :inherit my-default-prose
                            :height 1.3
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-6 `((t :inherit my-default-prose
                            :height 1.2
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-7 `((t :inherit my-default-prose
                            :height 1.1
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-8 `((t :inherit my-default-prose
                            :height 1.0
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-uri-face `((t :inherit link))
  "Face used to display URIs."
  :group 'my-typography)
#+end_src

The goal is to customize the fonts I want to have follow one of these rules by resetting all its values to ='unspecified= and inheriting one of my typography faces.

To help the tedious task of resetting a face, I want to have a helper function that will do the work for me:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defsubst my-typography-reset (&rest faces)
  "Mark all face attributes from each face on FACES as `unspecified'."
  (custom-set-faces!
            `(,faces
              :family unspecified
              :foundry unspecified
              :width unspecified
              :height unspecified
              :weight unspecified
              :slant unspecified
              :underline unspecified
              :overline unspecified
              :strike-through unspecified
              :box unspecified
              :stipple unspecified
              :font unspecified
              :fontset unspecified
              :extend unspecified)))
#+end_src

The astute reader might ask: /"Why not have this function do the whole work of resetting the font and assign an inheritance?"/

Unfortunately at this point, the answer is not clear. When I tried to implement the /one-shot/ function, the target face would not get the inheritance value, and fonts were all messed up.

By splitting the process into cleaning and then setting, Emacs seams to behave as expected.

#+begin_note
If you know what is going on here, please let me know. I'll be more than happy to learn and credit you for that!
#+end_note

#+begin_center
◆
#+end_center

To start the configuration, I will get the Doom's font system configured accordingly to my typography:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-font (face-attribute 'my-default-mono :font)
      doom-big-font (face-attribute 'my-big-face-mono :font)
      doom-variable-pitch-font (face-attribute 'my-default-prose :font))
#+end_src

It would be great if Doom could accept a /face/ as the value for these variables, but unfortunately, it does not. Until this change, I have to live with this anonymous face that copy the =font= attribute from my typography face.

The next step is to make sure the base faces used on the editor match my base typography. The process to do so is the same I will use throughout this document whenever I find a mode that I need to adjust to match the defined typography.

I first clean up all styles except color on the faces I want to configure, in this case the faces are ~fixed-pitch~ and ~variable-pitch~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset 'fixed-pitch 'variable-pitch)
#+end_src

Then I set each face inheritance to the correct typography face:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(fixed-pitch :inherit my-default-mono)
  '(variable-pitch :inherit my-default-prose))
#+end_src

At his point, Emacs have ~'default~, ~'fixed-pitch~, and ~'variable-pitch~ faces matching my selection of fonts. This is, probably, a major part on the typography configuration. The rest of my setup, are individual packages, which I will configure once they show up in this document.

To close out the typography section, I like to enable font smoothing on macOS. To do so, simply set ~ns-use-thin-smoothing~ to =t=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq ns-use-thin-smoothing t)
#+end_src

*** Iconography
Doom offers the ~all-the-icons~ package, which allow one to insert Unicode glyphs on buffers. That is a great start, but the problem I see here is how inconsistent the size of these icons are.

The idea for this section is to create a list of curated icons, adjusted to occupy exactly 2 ASCII characters on the buffer. This allows for a better alignment of text when we use an Icon.

I will create an /Association List/ to store symbols associated with an adjusted icon:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defconst my-supported-icons
  (list 'assign       (all-the-icons-material "assignment_ind"          :height 0.95 :v-adjust -0.17)
        'bug          (all-the-icons-material "bug_report"              :height 0.95 :v-adjust -0.17)
        'busy         (all-the-icons-material "event_busy"              :height 0.95 :v-adjust -0.17)
        'calendar     (all-the-icons-octicon  "calendar"                :height 1.05 :v-adjust 0.0)
        'checked      (all-the-icons-material "check_box"               :height 0.95 :v-adjust -0.17)
        'checklist    (all-the-icons-octicon  "checklist"               :height 0.95 :v-adjust 0.1)
        'contact-add  (all-the-icons-material "person_add"              :height 0.95 :v-adjust -0.17)
        'error        (all-the-icons-material "error_outline"           :height 0.95 :v-adjust -0.17)
        'globe        (all-the-icons-faicon   "globe"                   :height 1.15 :v-adjust -0.05)
        'help         (all-the-icons-material "live_help"               :height 0.95 :v-adjust -0.22)
        'history      (all-the-icons-material "history"                 :height 0.95 :v-adjust -0.17)
        'idea         (all-the-icons-material "lightbulb_outline"       :height 0.95 :v-adjust -0.17)
        'inbox        (all-the-icons-material "inbox"                   :height 0.95 :v-adjust -0.15)
        'journal      (all-the-icons-material "book"                    :height 0.95 :v-adjust -0.15)
        'list         (all-the-icons-faicon   "list"                    :height 0.93 :v-adjust -0.05)
        'loop         (all-the-icons-material "loop"                    :height 0.95 :v-adjust -0.17)
        'meeting      (all-the-icons-material "date_range"              :height 0.95 :v-adjust -0.15)
        'new          (all-the-icons-material "new_releases"            :height 0.95 :v-adjust -0.17)
        'notes        (all-the-icons-material "library_books"           :height 0.95 :v-adjust -0.1)
        'pause        (all-the-icons-material "pause_circle_outline"    :height 0.95 :v-adjust -0.17)
        'postit       (all-the-icons-faicon   "sticky-note"             :height 1.15 :v-adjust 0.05)
        'project      (all-the-icons-octicon  "briefcase"               :height 1.05 :v-adjust 0.05)
        'review       (all-the-icons-material "rate_review"             :height 0.95 :v-adjust -0.15)
        'semi-checked (all-the-icons-material "indeterminate_check_box" :height 0.95 :v-adjust -0.17)
        'snooze       (all-the-icons-material "snooze"                  :height 0.95 :v-adjust -0.17)
        'stop         (all-the-icons-octicon  "stop"                    :height 1.05 :v-adjust -0.05)
        'timer        (all-the-icons-material "timer"                   :height 0.95 :v-adjust -0.15)
        'unchecked    (all-the-icons-material "check_box_outline_blank" :height 0.95 :v-adjust -0.17)
        'visibility   (all-the-icons-material "visibility"              :height 0.95 :v-adjust -0.17)
        'wait         (all-the-icons-material "hourglass_empty"         :height 0.95 :v-adjust -0.17))
  "Property list with all supported icons from my configuration.")
#+end_src

In order to allow other parts of this configuration to leverage the curated icons, I'll create a predicate function to check if a given symbol has an icon associated with it:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-supported-icons-p (icon)
  "Return t if the symbol given on ICON, is one associated with supported icon."
  (and (boundp 'my-supported-icons)
       (listp my-supported-icons)
       (plist-member my-supported-icons icon)))
#+end_src

I want to also create a thin-wrapper around the ~plist-get~ to retrieve the icon string for a given symbol:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-raw-icon (icon)
  "This function returns the requested ICON as if you're calling the
`all-the-icons-'* functions directly.

Icons supported by this function were all optimized to use exactly 2 characters
of space when used with the font and size defined in the main configuration.

Check th documentation of `my-supported-icons' to see the list of supported
icons."
  (plist-get my-supported-icons icon))
#+end_src

And to finalize my icons configuration, I need to expose a function where one (me in this case) will call it to get a curated icon with a given color (this is the only function in this section that a user should call to get an icon).

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-icon (icon &optional color)
  "This function returns the requested ICON as a 2-characters string,
propertized to display the associated icon from the `all-the-icons' package. It
uses the COLOR arg to 'paint' the icon.

Check documentation of the function `my-raw-icon' for a list of supported
icons."
  (cond ((eq color 'raw) (my-raw-icon icon))
        (color (propertize "--"
                   'face `(:foreground ,color)
                   'display (my-raw-icon icon)))
        (t (propertize "--"
                   'face `(:foreground ,(face-attribute 'default :foreground))
                   'display (my-raw-icon icon)))))
#+end_src

** Editor Tabs
I've been all over the place regarding the use of tabs on editors. I used to think they were useless, since all files on my editor were buffers, not tabs. I though that using tabs as a sort of layout manager was a great idea, because I would have the visual cue of /workspaces/ I had configured.

Recently, I spent time thinking about this, and I changed my mind regarding tabs. First, I believe the common knowledge that one tab represents one file, is too ingrained into our collective minds by all other software that use them (web browsers, IDEs, file managers, etc.). This causes a weird feeling when I look to the tabs, and they do not represent opened files. Also, as I work on my editor, I lose track of files opened without tabs.

For some Emacs users, all these arguments are silly because they are too used to the way Emacs works. But I believe that this argument should be the other way around. Because of the way Emacs developers decided to use the tab paradigm inside the editor, Emacs users accepted and got used to it.

But, as if to point out things I'm arguing for, there are way too many packages that say they /fix the Emacs window system/ on GitHub these days.

On 2020, I read a blog post from [[https://andreyorst.gitlab.io/][Andrey Listopadov]] about his desire to have [[https://andreyorst.gitlab.io/posts/2020-05-07-making-emacs-tabs-work-like-in-atom/][Emacs tabs behaving more like tabs on Atom]]. The post itself is an excellent read, but I would like to reproduce here Andrey's description of how he believes the tab behavior should be:

#+begin_quote
In Emacs, however, we can’t close tab via close button, because it will cycle buffers, so instead we can switch to second policy of killing buffer instead. But it will not work either, because it will not kill the window, and it will kill buffer in all windows. So how do we fix this?

First let’s establish some logical rules:

- Buffer can exist without a tab, but tab can not exist without a buffer,
- If tab was closed buffer should be killed only if there are no tabs for this buffer left,
- If tab was closed and there are no more tabs in the window, window should be killed.

These three rules are basically how tabs work in modern editors.
#+end_quote

The configuration you're reading here is almost a copy from Andrey's posts (there is a sequel to the aforementioned post called [[https://andreyorst.gitlab.io/posts/2020-05-10-making-emacs-tabs-look-like-in-atom/][Making Emacs tabs look like in Atom]], that I also copy snippets in order fully configure tabs here.) with minor modifications to adjust it to my code style.

The way to achieve this configuration, is to define a set of ~tab-line~ variables and let Emacs do its thing.

My tab configuration uses dynamic values in almost all of it, but there are two constants that I have to decide beforehand: ~tab-line-tab-min-width~ and ~tab-line-tab-max-width~.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defconst tab-line-tab-min-width 20
  "Minimum width of a tab in characters.")

(defconst tab-line-tab-max-width 70
  "Maximum width of a tab in characters.")
#+end_src

It might look an exaggeration to use the values I chose, but since I will use a variable pitch face to draw the tabs, these numbers become more realistic.

So let's configure the faces used on my tabs:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs--setup-faces-h ()
  "Configure the `tab-line-mode' user interface."
  (let* ((base (if (and (facep 'solaire-default-face)
                        (not (eq (face-attribute 'solaire-default-face :background) 'unspecified)))
                   (face-attribute 'default :background)
                 (face-attribute 'mode-line :background)))
         (bg (if (and (facep 'solaire-default-face)
                      (not (eq (face-attribute 'solaire-default-face :background) 'unspecified)))
                 (face-attribute 'solaire-default-face :background)
               (face-attribute 'default :background)))
         (fg (face-attribute 'default :foreground))
         (dark-fg (face-attribute 'shadow :foreground))
         (overline (face-attribute 'highlight :background))
         (box-width (/ my-line-pixel-height 2))
         (box-base (when (> box-width 0) (list :line-width box-width :color base)))
         (box-bg (when (> box-width 0) (list :line-width box-width :color bg))))
    (set-face-attribute 'tab-line nil
                        :background base
                        :foreground dark-fg
                        :overline base
                        :inherit 'my-default-ui
                        :box box-base)
    (set-face-attribute 'tab-line-tab nil
                        :foreground dark-fg
                        :background bg
                        :inherit 'my-default-ui
                        :box box-bg)
    (set-face-attribute 'tab-line-tab-inactive nil
                        :foreground dark-fg
                        :background base
                        :inherit 'my-default-ui
                        :box box-base)
    (set-face-attribute 'tab-line-tab-current nil
                        :foreground fg
                        :background bg
                        :inherit 'my-default-ui
                        :overline overline
                        :box box-bg)
    (set-face-attribute 'tab-line-highlight nil
                        :foreground fg
                        :background nil
                        :inherit 'tab-line-tab
                        :overline overline
                        :box box-bg)
    (set-face-attribute 'tab-line-close-highlight nil
                        :foreground overline
                        :overline overline
                        :background nil
                        :inherit 'tab-line-tab
                        :box box-bg)))
#+end_src

And I need to make sure I call this function after Doom loads the editor's theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'doom-load-theme-hook #'my-tabs--setup-faces-h)
#+end_src

To configure the look and feel of /non-tab/ elements of the ~tab-line~, I need to set the ~tab-line-right-button~, ~tab-line-left-button~, ~tab-line-new-button-show~, and ~tab-line-separator~ variables:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-right-button (propertize (if (char-displayable-p ?▸) " ▸ " " > ")
                                          'keymap tab-line-right-map
                                          'mouse-face 'tab-line-highlight
                                          'help-echo "Click to scroll right")
        tab-line-left-button (propertize (if (char-displayable-p ?◂) " ◂ " " < ")
                                         'keymap tab-line-left-map
                                         'mouse-face 'tab-line-highlight
                                         'help-echo "Click to scroll left")
        tab-line-new-button-show nil
        tab-line-separator ""))
#+end_src

And to configure the tab itself, I need to set the ~tab-line-close-button-show~, ~tab-line-close-button~, and the ~tab-line-tab-name-function~ variables:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-close-button-show t
        tab-line-close-button (propertize (format "%s " (all-the-icons-material "close"))
                                          'keymap tab-line-tab-close-map
                                          'mouse-face 'tab-line-close-highlight
                                          'face 'tab-line-tab-curent
                                          'help-echo "Click to close tab")
        tab-line-tab-name-function #'my-tabs-name-buffer))
#+end_src

While the ~tab-line-close-button-show~ and the ~tab-line-close-button~ variables control the appearance of the tab close button, the ~tab-line-tab-name-function~ is responsible for everything else on the tab. The ~my-tabs-name-buffer~ function will return a string representing the tab name for each tab, and is also this function's responsibility to return the normalized tab size in form of blank spaces:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-name-buffer (buffer &rest _buffers)
  "Create name for tab with padding and truncation.

If buffer name is shorter than `tab-line-tab-max-width' it gets centered with
spaces, otherwise it gets truncated, to preserve equal width for all tabs. This
function also tries to fit as many tabs in window as possible, so if there are
no room for tabs with maximum width, it calculates new width for each tab and
truncates text if needed. You can set the minimal width with
`tab-line-tab-min-width' variable."
  (with-current-buffer buffer
    (let* ((window-width (window-width (get-buffer-window)))
           (close-button-size (if tab-line-close-button-show
                                  (length (substring-no-properties tab-line-close-button))
                                0))
           (tab-amount (length (funcall tab-line-tabs-function)))
           (window-max-tab-width (/ window-width tab-amount))
           (tab-width (- (cond ((>= window-max-tab-width tab-line-tab-max-width)
                                tab-line-tab-max-width)
                               ((< window-max-tab-width tab-line-tab-min-width)
                                tab-line-tab-min-width)
                               (t window-max-tab-width))
                         close-button-size))
           (buffer-name (string-trim (buffer-name)))
           (name-width (length buffer-name)))
      (if (>= name-width (- tab-width 3))
          (concat  " " (truncate-string-to-width buffer-name (- tab-width 3)) "… ")
        (let* ((padding (make-string (/ (- tab-width name-width) 2) ?\s))
               (buffer-name (concat padding buffer-name))
               (name-width (length buffer-name)))
          (concat buffer-name (make-string (- tab-width name-width) ?\s)))))))
#+end_src

The reader might have noticed I use the size of the list returned by the function ~tab-line-tabs-function~ to calculate single tab size, and as you imagine, the function symbol used in this variable is responsible to return a list of tabs on the current window, so I will also use such function to filter some unwanted buffers on the tab bar. The function's docstring, explains these exceptional cases in a bit more detail:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-mode-persp-window ()
  "Return a list of buffer tabs of the current window.

This function take in account the active perspective (or workspace) so it does
not display tabs from other perspectives on the current one.

There are 4 types of buffer that this function handles:

1. Real buffers

   These buffers are the normal buffers that have a tab associated with them. To
   be a real buffer, the function `doom-real-buffer-p' must return t for the
   buffer.

2. Popup buffers (or non-real buffers)

   These are the inverse of real buffers.

3. Org capture buffers

   These buffers are the ones created to perform the `org-capture'. Such buffers
   should never have a tab associated with them.

4. Dired buffers

   These are real buffers that should never exist in more than one per window.
   When jumping from one Dired buffer to another, Emacs creates one buffer per
   directory, but the tab bar should not display any other then the current
   buffer."
  (let ((win-buffs (tab-line-tabs-window-buffers))
        (last-dired-buf (seq-find 'doom-dired-buffer-p (buffer-list (selected-frame)))))
    (reverse (seq-filter (lambda (buf)
                           (let ((buf-name (buffer-name buf)))
                             (and (member buf win-buffs)
                                  (doom-real-buffer-p buf)
                                  (not (string-prefix-p buf-name "CAPTURE-"))
                                  (or (not (doom-dired-buffer-p buf))
                                      (eq buf last-dired-buf)))))
                         (funcall tab-line-tabs-buffer-list-function)))))
#+end_src

And as with the ~tab-line-tabs-function~, the ~tab-line-tabs-buffer-list-function~ holds a symbol of a function that returns all buffers to consider during ~tab-line-tabs-function~ execution, and I should set them to their proper functions, unfortunately the ~persp-current-buffers~ (which is the function we need to call), is a macro, and according to the Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Calling-Functions.html][documentation]], we can't pass macros to ~funcall~ or ~apply~.

To workaround this problem, I will create an alias function to call the same functions the ~persp-current-buffers~ macro do:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defalias 'my-persp-current-buffers
  (lambda ()
    (when (fboundp 'persp-buffers)
      (persp-buffers (get-current-persp))))
  "Wrapper for the `persp-current-buffers' macro.")
#+end_src

Now we can properly define the two variables we need to make ~tab-line~ find the tab buffers:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-tabs-function #'my-tabs-mode-persp-window
        tab-line-tabs-buffer-list-function #'my-persp-current-buffers))
#+end_src

The last variable to configure is the ~tab-line-exclude-modes~. This variable holds a list of modes that will not have ~tab-line-mode~ enabled on them, even when ~global-tab-line-mode~ gets enabled:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! tab-line
  (setq tab-line-exclude-modes '(+doom-dashboard-mode
                                 cfw:calendar-mode
                                 Info-mode
                                 calendar-mode
                                 ediff-mode
                                 eshell-mode
                                 help-mode
                                 helpful-mode
                                 imenu-list-major-mode
                                 lexic-mode
                                 process-menu-mode
                                 Man-mode
                                 WoMan-mode
                                 term-mode
                                 treemacs-mode
                                 vterm-mode
                                 wordnut-mode
                                 reb-mode)))
#+end_src

Even with the ~tab-line-exclude-modes~ list, some /non-real/ buffers get displayed. I need to create an extra function to help me get rid of the ~tab-line~ when I load such buffers:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-hide-tab-line-maybe-h ()
  "Disable `tab-line-mode' for non-real buffers.

For a definition of what is a non-real buffer, check the documentation of
`doom-real-buffer-p'."
  (when (not (doom-real-buffer-p (current-buffer)))
    (tab-line-mode -1)))
#+end_src

With the helper function defined, I need to make sure I call it when I switch buffers. The reason for that is that I could explicitly request to load a /non-real/ buffer, which would create the ~tab-line~ on such buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'doom-switch-buffer-hook #'my-tabs-hide-tab-line-maybe-h)
#+end_src

Also, when Emacs calls the ~window-configuration-change-hook~ hooks, I need to clean all ~tab-line~ cache to make sure Emacs will re-consider all the proper buffers when re-displaying it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'window-configuration-change-hook #'my-tabs--drop-caches-h)
#+end_src

The implementation of ~my-tabs--drop-caches-h~ simply /nullify/ the value of the ~tab-line-cache~ window parameter for all windows:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs--drop-caches-h ()
  "Drops `tab-line' cache in every window."
  (dolist (window (window-list))
    (set-window-parameter window 'tab-line-cache nil)))
#+end_src

With all that in place, we can make sure the ~tab-line~ gets loaded when Emacs start:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! tab-line
  :when window-system
  :hook ((after-init . global-tab-line-mode)))
#+end_src

*** Tab actions
There are two main actions that I need to address here: selection and closing.

I would like to start talking about the latter. Unfortunately, the Emacs implementation of ~tab-line-close-tab~ does not leave room to customize its behavior the way I want it. Instead, I will implement my own version (more like "I'll copy Andrey's version and change it a bit"):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tabs-close-buffer-tab (buffer-or-name &optional window)
  (let ((buffer (get-buffer buffer-or-name))
        (window (or window (get-buffer-window))))
    (if window
        (with-selected-window window
          (let ((tab-list (my-tabs-mode-persp-window))
                (buffer-list (flatten-list
                              (seq-reduce (lambda (list window)
                                            (select-window window t)
                                            (cons (my-tabs-mode-persp-window) list))
                                          (window-list) nil))))
            (select-window window)
            (if (> (seq-count (lambda (b) (eq b buffer)) buffer-list) 1)
                (progn
                  (if (eq buffer (current-buffer))
                      (bury-buffer)
                    (set-window-prev-buffers window (assq-delete-all buffer (window-prev-buffers)))
                    (set-window-next-buffers window (delq buffer (window-next-buffers))))
                  (unless (cdr tab-list)
                    (ignore-errors (delete-window window))))
              (and (kill-buffer buffer)
                   (unless (cdr tab-list)
                     (ignore-errors (delete-window window)))))))
      (if (persp-buffer-in-other-p buffer)
          (persp-remove-buffer buffer)
        (kill-buffer buffer)))))
#+end_src

With the function implemented, I need to override the original one with it using an advice:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-tabs-close-tab-a (&optional mouse-event)
  "Close the selected tab.

If buffer on tab is present in another window, close the tab by using
`bury-buffer' function. If buffer on tab is unique to all existing windows, kill
the buffer with `kill-buffer' function. Lastly, if no tabs left in the window,
it will delete it with `delete-window' function."
  :override 'tab-line-close-tab
  (let* ((posnp (and mouse-event (event-start mouse-event)))
         (window (and posnp (posn-window posnp)))
         (buffer (or (and posnp (get-pos-property 1 'tab (car (posn-string posnp))))
                     (current-buffer)))
         (window (or window (get-buffer-window buffer))))
    (my-tabs-close-buffer-tab buffer window)
    (force-mode-line-update)))
#+end_src

Now, any code calling the ~tab-line-close-tab~ will use the algorithm defined in this section.

#+begin_center
◆
#+end_center

The next and final action to handle is actually a group of actions related to /switching between tabs/.

The first step to configure tab switching, is to create a function that allows me to switch to any tab, by passing a tab to it. The only special thing about this function is that you can pass a buffer or an association list representing a tab. Other than that, this function behaves much like the ~switch-to-buffer~ one:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to-tab (tab)
  "Switch to the buffer associated with TAB."
  (let ((buffer (if (bufferp tab) tab (cdr (assq 'buffer tab)))))
    (when (bufferp buffer)
        (switch-to-buffer buffer))))
#+end_src

Next, I need a way to select a tab by its position of the displayed tabs:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to (pos)
  "Switch to the tab on position POS.

If POS is negative, access the tab on the reverse order.

If POS is bigger than the number of tabs, return nil. The same is valid for
negative numbers, so if POS is negative and its absolute value minus 1 is bigger
than the number of tabs, return nil."
  (let* ((tabs (funcall tab-line-tabs-function))
         (tabs (if (< pos 0) (reverse tabs) tabs))
         (pos (if (< pos 0) (1- (- pos)) pos))
         (tab (nth pos tabs)))
    (unless (my-tab-line-switch-to-tab tab)
      (user-error "There is no tab on position %s" (1+ pos)))))
#+end_src

And a helper function to select the last tab on the list:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-tab-line-switch-to-final ()
  "Switch to the last tab."
  (interactive)
  (let* ((tab (car (last (funcall tab-line-tabs-function)))))
    (unless (my-tab-line-switch-to-tab tab)
      (user-error "Tab line is not visible to go to the last tab"))))
#+end_src

These functions should be enough to allow me to switch tabs on any way I defined here. To get a good set of key bindings, I need to create aliases for calling ~my-tab-line-switch-to~ from 1 to 9:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(dotimes (i 9)
  (defalias (intern (format "my-tab-line-switch-to-%d" i))
    (lambda () (interactive) (my-tab-line-switch-to i))
    (format
     "Thin wrapper around `+workspace/switch-to' function where we pass #%d as the INDEX parameter."
     (1+ i))))
#+end_src

And my keymap for all these functions should allow me to switch tabs using =Cmd= plus a number from =1= to =9=. The =Cmd-0= shortcut will call the ~my-tab-line-switch-to-final~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after tab-line
      :ne "s-1" #'my-tab-line-switch-to-0
      :ne "s-2" #'my-tab-line-switch-to-1
      :ne "s-3" #'my-tab-line-switch-to-2
      :ne "s-4" #'my-tab-line-switch-to-3
      :ne "s-5" #'my-tab-line-switch-to-4
      :ne "s-6" #'my-tab-line-switch-to-5
      :ne "s-7" #'my-tab-line-switch-to-6
      :ne "s-8" #'my-tab-line-switch-to-7
      :ne "s-9" #'my-tab-line-switch-to-8
      :ne "s-0" #'my-tab-line-switch-to-final

      (:prefix "g"
       :desc "Go to tab on the right" :n "t" #'tab-line-switch-to-next-tab
       :desc "Go to tab on the left"  :n "T" #'tab-line-switch-to-prev-tab))
#+end_src

One final configuration I need to do is to make sure Emacs selects the correct tab when I click on it with the mouse:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-tabs-select-tab-a (&optional e)
  "Advice to select the buffer window of a tab when clicking on the tab."
  :after 'tab-line-select-tab
  (select-window (posn-window (event-start e))))
#+end_src

*** Windows
It's impossible to get the tab configuration right without adjusting the Emacs window behavior.

The main behavior I want to guarantee, is that Emacs should close a window if there are no buffers left on the list of previous buffers:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-close-window-when-kill-buffer-h (&optional buffer-or-name)
  (let* ((buf (get-buffer (or buffer-or-name (current-buffer))))
         (win (get-buffer-window buf)))
    (when (and win (my-window-single-buffer-p win))
      (delete-window win))))
#+end_src

Because this function needs to know if there are no buffer lefts on the list of buffers associated with the window, I will implement a helper function for that:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defsubst my-window-single-buffer-p (&optional win)
  (let ((win (or win (selected-window))))
    (or (window-dedicated-p win)
        (not (or (window-next-buffers win)
                 (window-prev-buffers win))))))
#+end_src

Now I just need to make sure Emacs calls the ~my-close-window-when-kill-buffer-h~ function when I kill a buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-buffer-hook 'my-close-window-when-kill-buffer-h)
#+end_src

These covers most of the closing behavior regarding windows. The one exception is the ~kill-current-buffer~ that needs to not switch buffers as we kill the current buffer. I will implement this behavior as a /before/ advice to the ~kill-current-buffer~ function:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-close-window-when-no-buffer-a (&rest _)
  :before-until #'kill-current-buffer
  (my-save-all-buffers-a)
  (let ((buf (current-buffer))
        (tabs (my-tabs-mode-persp-window)))
    (cond
     ((window-dedicated-p) (delete-window) t)
     ((eq buf (doom-fallback-buffer)) (message "Can't kill the fallback buffer.") t)
     ((doom-real-buffer-p buf)
      (let ((doom-inhibit-switch-buffer-hooks-original doom-inhibit-switch-buffer-hooks)
            (inhibit-redisplay t)
            buffer-list-update-hook)
        (if (memq buf tabs)
            (progn
              (when (and (doom-real-buffer-p buf)
                         (buffer-file-name buf)
                         (buffer-modified-p buf)
                         (not (y-or-n-p (format "Buffer %s has unsaved changes; kill it anyway?" buf))))
                (user-error "Aborted"))
              (tab-line-close-tab))
          (with-current-buffer buf
            (restore-buffer-modified-p nil))
          (kill-buffer buf))
        (setq doom-inhibit-switch-buffer-hooks doom-inhibit-switch-buffer-hooks-original))
      (run-hooks 'buffer-list-update-hook)
      t))))
#+end_src

To finish the window changes, I need to make sure Doom does not switch to the fallback buffer (a.k.a. the Dashboard buffer) when there are no more buffers left on the window:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(advice-remove 'kill-current-buffer #'doom--switch-to-fallback-buffer-maybe-a)
#+end_src

** Special modes
The configuration in this section, belongs to some modes that I use all over the place or that are not big enough to justify their own section in this document.

In practice, most of the configurations here are about the mode's appearance, and where they show their content.

*** Info mode
The Info mode is where all user manuals exist. Up to now, I'm not used to read and search through the manuals, but I feel this is a habit I must acquire.

First I need to make the manuals to /look/ nicer (if you're rolling your eyes right now, have a remembering read into the section [[Appearances]]).

Although this is not a radical change, there are two font lock additions I want to do. The first is a symbol to represent the /menu/ for the current info page, and the second is to replace the =*= character as the list item markup, by the character I will use on all other modes that deal with lists:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! info
  (font-lock-add-keywords
   'Info-mode
   `(("^\\(\\*\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))
     ("^[\t ]*\\(\\*\\) Menu\\(:\\)"
      (0 (prog1 ()
           (compose-region (match-beginning 1) (match-end 1) "☰")
           (put-text-property (match-beginning 2) (match-end 2) 'invisible t)
           )))) t))
#+end_src

There is a package called [[https://www.emacswiki.org/emacs/InfoPlus][~info+.el~]], available through the Emacs Wiki, that fontify the ~Info-mode~ buffer to make it look nicer.

Unfortunately the latest changes introduced in March broke the package on Emacs 27 and 28, so in order to still have the nice feature it provides with a version that still works on my Emacs, I need to /pin/ the package to the version that still works:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! info-plus :pin "5ecd4c1e3f1384bffb386e61a8e3788652e55c25")
#+end_src

Due to the nature of this package, we need to load it only when we need to fontify the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! info-plus :commands Info-toggle-fontify-all)
#+end_src

But when this actually happens? The best place to add this, is the hook ~Info-selection-hook~. First I need to define a function that will configure the mode when any info page gets selected:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info--fontify-info-h ()
  "Hook called to fontify the Info buffer.

This function lexically bind some configuration for the `into-plus' package,
and call the `Info-toggle-fontify-all' to perform the fontification work.

Notice we need to update the font lock overlays after this call to guarantee
the fontification didn't remove any important overlay."
  (let ((Info-fontify-angle-bracketed-flag nil)
        (Info-fontify-bookmarked-xrefs-flag nil)
        (Info-fontify-emphasis-flag nil)
        (Info-fontify-glossary-words nil)
        (Info-fontify-isolated-quote-flag nil)
        (Info-fontify-quotations nil)
        (Info-fontify-reference-items-flag nil)
        (Info-fontify-visited-nodes nil))
    (call-interactively 'Info-toggle-fontify-all)
    (font-lock-update)))
#+end_src

Then, I can hook it to the ~Info-selection-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-selection #'my-info--fontify-info-h)
#+end_src

The next step is to make sure the ~Info-mode~ respects the typography I defined earlier. First we clean up any outstanding setup to the faces that need to get adjusted:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset (cl-loop for i from 1 to 4 collect (intern (format "info-title-%d" i))))
(my-typography-reset 'info-menu-header)
#+end_src

And then, we modify all the faces to match my particular configuration:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(info-title-1 :inherit outline-1 :weight unspecified :extend unspecified)
  '(info-title-2 :inherit outline-2 :weight unspecified :extend unspecified)
  '(info-title-3 :inherit outline-3 :weight unspecified :extend unspecified)
  '(info-title-4 :inherit outline-4 :weight unspecified :extend unspecified)
  '(info-menu-header :inherit outline-5 :weight unspecified :extend unspecified)
  `(info-quoted-name :inherit font-lock-constant-face)
  `(info-isolated-quote :inherit info-quoted-name)
  `(info-isolated-backquote :inherit info-quoted-name)
  `(info-glossary-word :foreground ,(doom-color 'type 256)
                       :background ,(doom-darken 'type 0.7)
                       :box (:line-width 1 :color ,(doom-darken 'type 0.7) :style nil)
                       :inherit fixed-pitch)
  `(link-visited :foreground ,(doom-color 'violet 256))
  `(info-double-quoted-name :inherit font-lock-string-face)
  `(info-string :inherit font-lock-string-face)
  `(info-header-node :height 160
                     :inherit info-node)
  `(info-header-xref :height 160
                     :inherit info-xref))
#+end_src

There are two remaining configurations. The first one is to make the ~Info-mode~ buffer to match how it gets displayed on the editor. I will use ~writeroom~ to make the buffer centralized on the window, and will turn on ~variable-pitch-mode~:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (variable-pitch-mode 1)
  (visual-line-mode 1))
#+end_src

With the function that will configure my buffer in place, I need to hook it to the mode initialization:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-mode #'my-info-buffer-config-h)
#+end_src

The last configuration for the ~Info-mode~ is *where* its buffer gets displayed. For me, it should show up on the right side of my screen. I can achieve that with a popup rule for the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*info\\*$"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)
#+end_src

*** Help mode and Man mode
I want to give a similar treatment I did to the ~Info-mode~ to both these modes, and like the ~Info-mode~, the first thing to do is to create the functions that will configure these modes:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-help-man-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (visual-line-mode 1))
#+end_src

And then, hook them up to their modes hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! (help-mode
            helpful-mode
            Man-mode
            WoMan-mode)
           #'my-help-man-buffer-config-h)
#+end_src

The last step on these configurations is to add a popup rule for each mode to make their buffers to open on the right side of the editor:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*[Hh]elp"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)

(set-popup-rule! "^\\*\\(?:Wo\\)?Man "
  :slot 2   :vslot -1     :side 'right  :width 88 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0     :quit t)
#+end_src

*** Rainbow mode
The Rainbow mode is a small visual helper to display colors on the buffer, whenever it finds a string that can be a color.

I already configured a key binding (=SPC t R=) to toggle this mode.

What I still need to do, is to make sure that I use a fixed font when displaying the color text, unfortunately, the ~rainbow-mode~ uses an anonymous face to display the colors, so the only way for me to customize it, is to override the ~rainbow-colorize-match~ with a function that add any property I want to the face (in this case, to inherit from the ~fixed-pitch~ face):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-fontify-rainbow-colorize-match-a (color &optional match)
  "Return a matched string propertized with a face whose background is COLOR.

This function computes the foreground using `rainbow-color-luminance', and is
either white or black."
  :override 'rainbow-colorize-match
  (let ((match (or match 0)))
    (put-text-property
     (match-beginning match) (match-end match)
     'face `((:foreground ,(if (> 0.5 (rainbow-x-color-luminance color))
                               "white" "black"))
             (:background ,color)
             (:inherit fixed-pitch)))))
#+end_src

* Development
TBD

** TODO Requirements

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! lsp-ui
  :defer t
  :custom
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable t))
#+end_src

** TODO Common configuration
TBD

*** Version control system

- https://github.com/Townk/gitmoji

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(if (getenv "GITHUB_WORKFLOW")
    (package! gitmoji
      :recipe (:host github
               :repo "Townk/gitmoji"))
  (package! gitmoji
    :recipe (:local-repo "~/workplace/personal/emacs/gitmoji")))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! gitmoji
  :commands (gitmoji-insert gitmoji-select)
  :init
  (setq gitmoji-insert-utf8-emoji t
        gitmoji-display-utf8-emoji t))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! magit
  ;; (remove-hook 'server-switch-hook 'magit-commit-diff)
  (add-hook 'git-commit-setup-hook 'my-git-commit-buffer-config-h))
#+end_src

#+caption: $DOOMDIR/autoload/development.el
#+begin_src emacs-lisp :tangle autoload/development.el
;;;###autoload
(defun my-git-commit-buffer-config-h ()
  "Configure the Git Commit Message buffer."
  (setq-local display-fill-column-indicator-column 72)
  (display-fill-column-indicator-mode 1)
  (goto-char (point-min))
  (evil-append-line 1)
  (yas-expand-snippet (yas-lookup-snippet "commit-message" 'git-commit-mode)))
#+end_src

#+caption: $DOOMDIR/snippets/git-commit-mode/commit-message
#+begin_src snippet :tangle snippets/git-commit-mode/commit-message
# name: commit-message
# key: msg
# --
${1:$$(unless (or yas-moving-away-p yas-modified-p)
              (yas-auto-next
                (condition-case nil
                    (or (gitmoji-select) "")
                  ('quit ""))))}${2:Subject}

;-------------------------------------------------|
;       Do not pass this column on the subject -> |
;-------------------------------------------------|
${3:`"## Changes Description\n"`}$0
; 1. Separate subject from body with a blank line
; 2. Limit the subject line to 50 characters
; 3. Capitalize the subject line
; 4. Do not end the subject line with a period
; 5. Use the imperative mood in the subject line
; 6. Wrap the body at 72 characters
; 7. Use the body to explain what and why vs. how
#+end_src

*** Comments
TBD

#+caption: $DOOMDIR/autoload/development.el
#+begin_src emacs-lisp :tangle autoload/development.el
;;;###autoload
(defadvice! my-comment-and-next-line-a (func &rest args)
  :around 'evilnc-comment-or-uncomment-lines
  (let ((no-selection-p (not (region-active-p))))
    (apply func args)
    (when no-selection-p
      (next-line)
      (goto-char (point-at-bol))
      (skip-chars-forward " \t\r"))))
#+end_src

** TODO Lisp
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq emacs-lisp-docstring-fill-column 80)
#+end_src

** TODO Shell script
** TODO Python
** TODO Javascript/TypeScript
** TODO C/C++
** TODO Swift
** TODO Kotlin
** TODO Java

* Non-editor features
TBD

** TODO Requirements
** TODO File management
Before we start configuring the target packages for this section (~dired~ and ~eshel~), I want to make some small adjustments to Treemacs. Although it is not a full blown file manager, it is a sort of a file manager for my projects, so it fits in this section.

The next change is to use our custom ~my-default-ui~ font face. I have to replace the entire ~doom-themes-enable-treemacs-variable-pitch-labels~ function with a version that uses my custom font instead. To do that, I'll use Emacs advices:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-themes-enable-treemacs-variable-pitch-labels-a (&rest _)
  "This advice changes the treemacs variable pitch font to one without serif so
the UI looks more polished."
  :override #'doom-themes-enable-treemacs-variable-pitch-labels
  (when doom-themes-treemacs-enable-variable-pitch
    (dolist (face '(treemacs-root-face
                    treemacs-git-unmodified-face
                    treemacs-git-modified-face
                    treemacs-git-renamed-face
                    treemacs-git-ignored-face
                    treemacs-git-untracked-face
                    treemacs-git-added-face
                    treemacs-git-conflict-face
                    treemacs-directory-face
                    treemacs-directory-collapsed-face
                    treemacs-file-face
                    treemacs-tags-face))
      (let ((faces (face-attribute face :inherit nil)))
        (set-face-attribute
         face nil :inherit
         `(my-default-ui ,@(delq 'unspecified (if (listp faces) faces (list faces)))))))))
#+end_src

By default, Treemacs will stay opened after you select a file to visit. Personally I don't like this, I rather have Treemacs closing when I select a file.

In order to help me achieve my desired behavior, I'll  create another /autoload/ function that I'll call when I select a file:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-visit-node-and-close-h (&optional arg)
  "Closes treemacs window after selecting a file to visit."
  (treemacs-visit-node-default arg)
  (delete-window (treemacs-get-local-window)))
#+end_src

We can now, configure Treemacs properly:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! treemacs
#+end_src

First we need to tell Treemacs to use the new autoload function when I press =<ENTER>= on a file:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (treemacs-define-RET-action 'file-node-open #'my-treemacs-visit-node-and-close-h)
  (treemacs-define-RET-action 'file-node-closed #'my-treemacs-visit-node-and-close-h)
#+end_src

Then, I like Treemacs to collapse directory into one when possible:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq treemacs-collapse-dirs (if (executable-find "python3") 3 0))
#+end_src

https://andreyorst.gitlab.io/posts/2020-05-01-dynamic-title-for-treemacs-workspace/

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-buffer-config-h ()
  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (face-remap-add-relative 'header-line
                             :background bg :foreground fg
                             :box `(:line-width ,(/ my-line-pixel-height 2) :color ,bg)))
  (setq header-line-format
        '((:eval
           (concat
            " ☰ "
            (propertize (s-titleize (persp-current-name)) 'face 'my-ui-window-header))))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (add-hook 'treemacs-mode-hook #'my-treemacs-buffer-config-h)
#+end_src

And finally, we can close our Treemacs configuration

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  )
#+end_src

I also like to make sure it behaves as expected if I use the mouse:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after treemacs
  (:map treemacs-mode-map
   [mouse-1] #'treemacs-single-click-expand-action))

 (:after treemacs-evil
  (:map evil-treemacs-state-map
   "C-h" #'evil-window-left
   "C-l" #'evil-window-right))

 (:after cfrs
  (:map cfrs-input-mode-map
   :n [escape] #'cfrs-cancel)))
#+end_src

Treemacs offers a function that adds the current project if it is not on the workspace. That is a nice feature, but because I use workspaces heavily, the fact that this function does not /remove/ projects that do not belong to this workspace bothers me, so I  wrote this advice to do the dirty work for me:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-treemacs-add-and-display-current-project-a ()
  "Open treemacs with current project. This function removes any project that is
not the current one."
  :override #'treemacs-add-and-display-current-project
  (interactive)

  (cl-dolist (p (treemacs-workspace->projects (treemacs-current-workspace)))
    (unless (string= (doom-project-name) (treemacs-project->name p))
      (treemacs-do-remove-project-from-workspace p t)))

  (when (treemacs-workspace->is-empty?)
      (treemacs-do-add-project-to-workspace (doom-project-root) (doom-project-name)))

  (treemacs-select-window)
  (treemacs-pulse-on-success))
#+end_src

And to finalize the Treemacs configuration, let's make it respect my window navigation keys:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-toggle-git-mode ()
  "Toggle `dired-git-info-mode' in git repos."
  (interactive)
  (when (and (not (file-remote-p default-directory))
             (locate-dominating-file "." ".git"))
    (call-interactively 'dired-git-info-mode)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-directory ()
  "Enters in the directory at point. If the cursor is not on a directory, do
nothing."
  (interactive)
  (let ((target-file (dired-get-file-for-visit)))
    (when (or (file-directory-p target-file)
              (dired-avfs--archive-p target-file))
      (dired-find-file))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-mac-quick-view ()
  "Invoke the macOS Quiclview on the file under point."
  (interactive)
  (shell-command (concat "qlmanage -p \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-widen-or-quit-all ()
  "If `dired-narow' is on, revert to the normal view. If there is no active
narrow, quit Dired."
  (interactive)
  (if dired-narrow-mode
      (revert-buffer)
    (mapc (lambda (buf)
            (let ((win (get-buffer-window buf)))
              (unless (append (window-prev-buffers win) (window-prev-buffers win))
                (delete-window win))
              (kill-buffer buf)))
          (doom-buffers-in-mode 'dired-mode))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-narrow (narrow-func)
  "Start a dynamic narrowing of files in current view."
  (interactive
   (list (if current-prefix-arg
             'dired-narrow-fuzzy
           'dired-narrow-regexp)))
  (call-interactively narrow-func))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-yank-absolute-path ()
  "Copy the absolute path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill 0))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-yank-relative-path ()
  "Copy the relative path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-externally ()
  "Open file with application defined by OS."
  (interactive)
  (shell-command (concat "open \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-reveal-on-finder ()
  "Show current file in Finder."
  (interactive)
  (shell-command (concat "open --reveal \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-marked-file-p ()
  "Return non-nil if we have marked file at point."
  (dired-file-marker (dired-get-file-for-visit)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-toggle-mark (&optional _)
  "Toggle mark of file at point."
  (interactive)
  (if (my-dired-marked-file-p)
      (dired-unmark 1)
    (dired-mark 1)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-split-right ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-right)
                           'window)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-split-bellow ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-below)
                           'window)))
#+end_src

- https://github.com/Fuco1/dired-hacks for all packages
- https://blog.breadncup.com/2012/05/27/emacs-sunrise-commander-and-avfs-fuse-unionfs-fuse-in-mac-os-x-lion/ for starting the avfsd service

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! dired-collapse)
(package! dired-narrow)
(package! dired-ranger)
(package! dired-quick-sort)
(package! dired-avfs)
(package! peep-dired)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! dired
  (setq
        auto-revert-verbose nil
        dired-dwim-target t
        dired-listing-switches "-lAhvFoG --group-directories-first"
        dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$\\|^.DS_STORE$\\|^.projectile$"
        dired-recursive-copies '(always)
        dired-recursive-deletes '(top)
        dired-use-ls-dired t
        global-auto-revert-non-file-buffers t
        insert-directory-program "gls"
        wdired-allow-to-change-permissions t
        wdired-allow-to-redirect-links t
        wdired-confirm-overwrite t))

(use-package! peep-dired
  :after dired
  :init
  (setq peep-dired-cleanup-on-disable t
        peep-dired-cleanup-eagerly t
        peep-dired-enable-on-directories nil))
(use-package! dired-collapse :after dired)
(use-package! dired-narrow :after dired)
(use-package! dired-quick-sort
  :hook ((dired-mode . dired-quick-sort)))
(use-package! dired-avfs
  :after dired
  :init
  (setq dired-avfs-root "~/.local/var/avfs"))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after dired
      (:map dired-mode-map
       :ne "t"        nil
       :ne "y"        nil
       :ne "c"        nil
       :ne "o"        nil
       :ne "m"        nil
       :ne "/"        #'my-dired-narrow
       :ne "<escape>" #'my-dired-widen-or-quit-all
       :ne "q"        #'my-dired-widen-or-quit-all
       :ne "RET"      #'dired-find-file
       :ne "TAB"      #'my-dired-open-directory
       :ne "<tab>"    #'my-dired-open-directory
       :ne "j"        #'dired-next-line
       :ne "k"        #'dired-previous-line
       :ne "l"        #'my-dired-open-directory
       :ne "h"        #'dired-up-directory
       :ne "U"        #'dired-up-directory
       :ne "R"        #'dired-do-rename
       :ne "d"        #'dired-do-delete
       :ne "x"        #'my-dired-toggle-mark
       :ne "p"        #'dired-ranger-paste
       :ne "M"        #'dired-ranger-move
       :ne "`"        #'dired-ranger-bookmark
       :ne "'"        #'dired-ranger-bookmark-visit
       (:prefix ("c" . "create")
        :desc "Create empty file"     :ne "f" #'dired-create-empty-file
        :desc "Create directory"      :ne "d" #'dired-create-directory
        :desc "Create project"        :ne "p" #'xxx)
       (:prefix ("m" . "mark")
        :ne "h" nil
        :desc "Mark directories"  :ne "d" #'dired-mark-directories
        :desc "Mark extension"    :ne "e" #'dired-mark-extension
        :desc "Mark hidden files" :ne "h" #'dired-mark-omitted
        :desc "Mark with regexp"  :ne "r" #'dired-mark-files-regexp
        :desc "Mark subdir files" :ne "s" #'dired-mark-omitted
        :desc "Unmark all files"  :ne "u" #'dired-unmark-all-files
        :desc "Remove all marks"  :ne "U" #'dired-unmark-all-marks
        :desc "Mark executables"  :ne "x" #'dired-mark-executables)
       (:prefix ("o" . "open")
        :desc "Open no split"         :ne "o" #'dired-find-alternate-file
        :desc "Quick view"            :ne "q" #'my-dired-mac-quick-view
        :desc "Reveal on Finder"      :ne "f" #'my-dired-reveal-on-finder
        :desc "Open vertically"       :ne "s" #'my-dired-open-split-bellow
        :desc "Open horizontally"     :ne "v" #'my-dired-open-split-right
        :desc "Open externally"       :ne "x" #'my-dired-open-externally)
       (:prefix ("t" . "toggle")
        :desc "Toggle collapsed dirs" :ne "c" #'dired-collapse-mode
        :desc "Toggle details"        :ne "d" #'dired-hide-details-mode
        :desc "Toggle git info"       :ne "g" #'my-dired-toggle-git-mode
        :desc "Toggle hidden files"   :ne "h" #'dired-omit-mode
        :desc "Toggle all marks"      :ne "m" #'dired-toggle-marks
        :desc "Toggle preview"        :ne "p" #'peep-dired
        :desc "Toggle sorting"        :ne "s" #'hydra-dired-quick-sort/body
        :desc "Toggle edit mode"      :ne "w" #'wdired-change-to-wdired-mode)
       (:prefix ("y" . "yank")
        :desc "Yank files"            :ne "y" #'dired-ranger-copy
        :desc "Copy absolut path"     :ne "a" #'my-dired-yank-absolute-path
        :desc "Copy file"             :ne "f" #'dired-do-copy
        :desc "Copy with regexp"      :ne "R" #'dired-do-copy-regexp
        :desc "Copy relative path"    :ne "r" #'my-dired-yank-relative-path))
      (:map wdired-mode-map
        :in "s-RET" #'wdired-finish-edit
        :in [s-return] #'wdired-finish-edit
        :in "s-ESC" #'wdired-revert
        :in [s-escape] #'wdired-revert))
#+end_src

** TODO Project management
Projectile is a great package. It usually provides more features that one particular user would need. But I still want to tweak it to make it behave more according my expectations.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-ignored-projects `("~/"
                                      "/tmp"
                                      ,(expand-file-name "straight/repos" doom-local-dir))))
#+end_src

Doom sets a function to run when we open a project with ~projectile~, but that function is not calling any /open file/ function for us. Let's create our own version of such function and help projectile to do the appropriate thing when we open a project.

The actions I expect are:

- Check if the project has one of the recognized files and open it, in this order (we should look for four extensions on each one of the files, also in this order: =.org=, no extension, =.md=, and =.rst=):
  + =CHANGELOG=
  + =NEWS=
  + =README=
- If none of the recognizable files is present, run ~project-find-file~;

Let's create such function as an /autoload/ function:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-after-switch-project-action-h (dir)
  "A project first action to execute when we switch our current project."
  (let ((file (file-exists-p! (ignore-errors (expand-file-name (or "README.org"
                                                                   "README.md"
                                                                   "README"
                                                                   "README.rst"
                                                                   "NEWS.org"
                                                                   "NEWS.md"
                                                                   "NEWS"
                                                                   "NEWS.rst"
                                                                   "CHANGELOG.org"
                                                                   "CHANGELOG.md"
                                                                   "CHANGELOG"
                                                                   "CHANGELOG.rst") dir)))))
    (if file
        (find-file file)
      (doom-project-find-file dir))))
#+end_src

And attach it to the ~projectile~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! projectile
  (setq +workspaces-switch-project-function #'my-after-switch-project-action-h))
#+end_src

** TODO Terminal
In general, I really like the setup Doom has for the terminal. There are 3 things I like to add there.

One are some aliases that I'm used to use when working on the terminal:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! eshell
  (set-eshell-alias!
   "d"     "dired $1"
   "edit"  "find-file-other-window $1"
   "em"    "find-file-other-window $1"
   "emacs" "find-file-other-window $1"
   "f"     "find-file $1"
   "gc"    "magit-commit $1"
   "gl"    "(call-interactively 'magit-log-current)"
   "gst"   "magit-status $1"
   "ls"    "exa --group-directories-first --color always -F $1"
   "la"    "exa --group-directories-first --color always -F -a $1"
   "ll"    "exa --group-directories-first --color always -F -l -h --git $1"
   "lla"   "exa --group-directories-first --color always -F -a -l -h --git $1"
   "rg"    "rg --color=always $*"
   "up"    "eshell-up $1"
   "pk"    "eshell-up-peek $1"
   "vi"    "find-file-other-window $1"
   "vim"   "find-file-other-window $1"))
#+end_src

Two is the window navigation mapping:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after eshell
      (:map eshell-mode-map
       :in "C-h" #'evil-window-left
       :in "C-j" #'evil-window-down
       :in "C-k" #'evil-window-up
       :in "C-l" #'evil-window-right))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*doom:\\(?:v?term\\|e?shell\\)-popup"
  :slot 2   :vslot -1     :side 'bottom  :width 110 :height 0.4
  :select t :modeline nil :autosave nil  :ttl nil   :quit nil)
#+end_src

And three is to fix ~magit-status~. When I'm on the terminal, if I open ~magit-status~, everything works as expected, but when I exit back to the terminal, Emacs switch the buffer on my terminal window to something else.

The ideal behavior would be to any app launch from the terminal to take over eshell's window until done. Then, revert back to the terminal.

I like to have a hint of the next possible completion while I'm working on shell. Zsh and Fish have great plugins for such feature, so I decided to add one for eshell as well:

- https://github.com/dieggsy/esh-autosuggest

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! esh-autosuggest)
#+end_src

The only configuration we need to get this mode working, is to let Emacs enable it when ~eshell-mode~ is up.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! esh-autosuggest
  :defer t
  :hook ((eshell-mode . esh-autosuggest-mode)))
#+end_src

** TODO Emails
TBD

* Appendix

** The =init.el= file
We can't tangle the =init.el= on Doom because it is always loaded before =doom sync= starts tangling =config.org=.

I have two alternatives here:

1. Let =init.el= as a lisp package;
2. Create a =doom sync= extension to tangle a =init.org= file;

For now, I will keep it as a separated Lisp file that I'm reproducing in this appendix for sake of documentation:

#+caption: $DOOMDIR/init.el
#+include: "~/.config/doom/init.el" src emacs-lisp :tangle no

** List of tables
#+TOC: tables

** List of figures
- [[fig:caco-demon][Figure 1: My favorite contender for a Doom Emacs logo]]

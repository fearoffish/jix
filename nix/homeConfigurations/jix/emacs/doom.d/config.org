#+TITLE:The Doomed Configuration
#+DESCRIPTION: A detailed setup for Emacs using Doom Emacs configuration framework
#+AUTHOR: Jamie van Dyke
#+EMAIL: me@fearof.fish

* My Literate Emacs Configuration

** About my config
I have built this from a single source

** Investigating issues
If you, like me, try new things with your config until it breaks, is important that we have some tools to help us figure out what is going on. Regardless if you'll use this configuration /as is/, or start yours from scratch, and copy the tidbits that may interest you. Before you start know these things:

To get a better sense of what is going on, start Emacs from terminal with the =--debug-init= flag:

#+caption: Command to start emacs in debug mode
#+begin_src shell :tangle no
emacs --debug-init
#+end_src

This will stop Emacs on the first error and print the stack trace for it. As of now, this might not be useful beyond reporting bugs, nevertheless, it's important you keep it in your mind!

Another issue that may show up, is slowness, specially after adding packages. This is not uncommon since Emacs startup time is sensitive to package loading.

What I recommend doing, is to install a package called [[https://github.com/kekeimiku/benchmark-init-el][~benchmark-init-el~]] that specializes on benchmarking (notice that I'm not using the [[https://github.com/dholm/benchmark-init-el][official repository]] for ~benchmark-init-el~, but a fork that fixed a bug when using it with Emacs 28+), and use it, when you have the need:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! benchmark-init
  :recipe (:host github
           :repo "kekeimiku/benchmark-init-el"))
#+end_src

Check my =init.el= file on the [[Appendix][Appendix]], to see how I hook up benchmarking to the =--debug-init= flag.

After starting Emacs with the =--debug-init= flag, you can check the call tree with the =M-x benchmark-init/show-durations-tree= command.

*** Sources:
- [[https://github.com/Townk/doom-emacs-private/blob/master/config.org][Thiago Alves Literate Config]]

*** Identity
Who am I?

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq user-full-name "Jamie van Dyke"
      user-mail-address "me@fearof.fish")
#+end_src

*** Dashboard
Doom Emacs offers a lightweight dashboard, that serves as the landing page for Emacs.

I really like the idea of a dashboard and I like even more what Doom offers, but, the ASCII art for its logo is not something I'm affectionate with.

In order to replace the ASCII art with something more pleasant and thematic, I like to add a small picture on the dashboard:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq +doom-dashboard-banner-dir (expand-file-name "assets" doom-private-dir)
      +doom-dashboard-banner-file "doom.png"
      +doom-dashboard-banner-padding '(0 . 4))
#+end_src

I love the style of this image so much, that it is, besides my dashboard image, my Emacs icon as well. The author of this beauty is [[https://github.com/eccentric-j/doom-icon][Jay Zawrotny]], feel free to send him an accolade!

#+begin_center
#+caption: My favorite contender for a Doom Emacs logo
#+name: fig:caco-demon
[[./assets/doom.png]]
#+end_center

*** Key modifiers
]]Since I use a Mac as my primary computer, I need to adjust its control keys to match a good set of control keys on Emacs:

#+caption: macOS key mappings
#+name: tbl:macos-keys
| macOS Key  | Emacs Key |
|------------+-----------|
| ⌘ (=cmd=)    | ='super=    |
| ⌃ (=ctrl=)   | ='control=  |
| ⌥ (=option=) | ='meta=     |

Emacs expose three variables to allow you to make these adjustments:

- ~mac-command-modifier~
- ~mac-control-modifier~
- ~mac-option-modifier~

To adjust this values according to table [[tbl:macos-keys]], set each one of them to the symbol described on the column =Emacs Key=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq mac-command-modifier 'super
      mac-control-modifier 'control
      mac-option-modifier  'meta)
#+end_src

*** Indentation
On this section, I will ask the reader to disagree on disagree, and set aside the almost religious subject of tabs versus spaces.

I prefer to always indent my files with =2= spaces with some rare exceptions for certain languages. To make Emacs use =2= spaces to indent by default, set the variable ~tab-width~ to =2=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default tab-width 2)
#+end_src

And to force emacs to always use spaces instead of tabs, set the ~indent-tabs-mode~ variable to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

*** Line wrapping
Until the writing of this document, I had the opinion that /soft wrap/ was evil, and it had no place on any editor. Since then, I learned to appreciate /soft wrap/ for prose, and later in this document, you will see all the other setup around /soft wrap/ and have an idea why I was so against it.

To prevent Emacs from wrapping your text as it goes over the size of the screen, set the variable ~truncate-lines~ to a non-=nil= value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default truncate-lines t)
#+end_src

*** Repeatable commands
There is a new feature available since Emacs 28 that allow you to define a /repeatable map/ for actions that take more than one keystroke to perform, and you want to repeat them with only the last keystroke in sequence.

For instance, on Doom, to increase the value of number, you need to use the key binding =g +=. If you want to increase the same number multiple times, you would have to type the same sequence multiple times (ignore the repeat command associated with the =.= key for didactic reasons).

I want to press =g +=, and then multiple keystrokes of =+= to increase the number multiple times, and the ~repeat-mode~ is the new feature that allows me to do that.

In order to use it, you have to define a keymap for the /repeatable keys/, and associate that keymap to the command that will start the repeat. This is an example on how to accomplish that:

#+caption: ~repeat-mode~ example for increment or rotate function
#+begin_src emacs-lisp :tangle no
(defvar my-inc-or-rotate-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "=" 'my-inc-or-rotate-at-point)
    (define-key map "-" 'my-dec-or-rotate-at-point)
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")

(put 'my-inc-or-rotate-at-point 'repeat-map 'my-inc-or-rotate-repeat-map)
(put 'my-dec-or-rotate-at-point 'repeat-map 'my-inc-or-rotate-repeat-map)
#+end_src

This is not bad, but with Lisp we can do better than that! The next macro helps with this process:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defmacro my-repeat-map! (map-name keys-alist &optional docstring)
  "A helper macro to create keymaps for repeatable actions.

MAP-NAME is the variable name for the sparse keymap created, and KEYS-ALIST, is
an association list of functions to keys, where each function is called after
the associated key is pressed after the repeatable action is triggered."
  `(defvar ,map-name
     (let ((map (make-sparse-keymap)))
       (dolist (cmd ,keys-alist)
         (define-key map (cdr cmd) (car cmd))
         (put (car cmd) 'repeat-map ',map-name))
       map)
     ,docstring))
#+end_src

You can find the previous example using the new macro on section [[Plus-Minus]].

In order to be able to use ~repeat-mode~ everywhere, I will turn it on after Emacs initializes:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'repeat-mode)
#+end_src

*** Completion framework
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! vertico
  (vertico-mouse-mode))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! marginalia
  (add-to-list 'marginalia-prompt-categories '("\\<Find file\\>" . file))
  (add-to-list 'marginalia-prompt-categories '("\\<project\\>" . file)))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq embark-action-indicator #'my-embark-which-key-action-indicator
      embark-become-indicator embark-action-indicator)
#+end_src

#+RESULTS:
: my-embark-which-key-action-indicator

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-embark-which-key-action-indicator (map target)
  "Helper function to display the `whichey' help buffer for embark."
  (which-key--show-keymap "Embark" map nil nil 'no-paging)
  #'which-key--hide-popup-ignore-command)
#+end_src

** Modal editing
As I mentioned on section [[Modal editing]], I do consider /Modal Editing/ far superior then other methods. The main reason is the separation of states while editing a text. At some level, we all do modal editing, but the keybindings style popularized by Vim goes a step forward and /formalize/ these states.

I decided to use Doom as the base of my configuration because it has good reasonable defaults, and its author is also an ex-/Vimer/ like me, so he tailored this distribution with a Vim user in mind.

On Emacs, the package responsible to provide Vim inside Emacs is [[https://github.com/emacs-evil/evil][Evil]], and from all Vim plugins for other editors that I use, Evil is by far the best. So much that compare it with other Vim plugins is doing injustice to Evil developers. More often than not, we call Evil the Vim inside Emacs.

In this section, I will go through configurations and other packages related directly to Evil, so if you don't use Evil or modal editing, feel free to skip this one.

#+begin_center
◆
#+end_center

If you're new to Vim, when you learn about the modes, on of the first /it's weird/ feelings you'll have is when you are in /Normal Mode/, then, you decide to go into /Insert Mode/ by pressing =i=, but right after that, you change your mind and press =<ESC>=... What just happened? You didn't act on anything, you didn't press any movement key, still, the cursor moved one character to the left!

Well, I have to tell you that this behavior is not a bug, is just how we should expect the change of modes to be.

I said /should/, because I disliked this behavior since I first used Vim. I never understood the rationale behind it and I always tried to fix it in my configurations. The good news is, Evil developers added an option to do just that.

To fix the moving back the cursor annoyance, set the variable ~evil-move-cursor-back~ to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-move-cursor-back nil)
#+end_src

After this configuration, one might realize that going to /Insert Mode/ using =a= and pressing =<ESC>= has the opposite effect of moving the cursor to the right. In this case, at least for me, this is an acceptable behavior since the user explicitly requested to go to /Insert Mode/ *after* the current character, is reasonable the editor to move your cursor to the next position.

#+begin_center
◆
#+end_center

On the same lines of /moving back the cursor/, there is another /expected/ behavior of Vim that I don't get it, the infamous /overwriting your clipboard with the contents of a selection that you just paste on top of it/ (I couldn't find a better way to refer to this behavior).

I'm sure that, at some point, this behavior made sense for a lot of developers, but in my personal opinion, if you are pasting the clipboard on top of a selected text, is highly unlikely that you want to use the contents of such selection right after pasting something on top of it. I believe the natural behavior of developers these days, is to consider the selected text you just paste on top of it, as gone.

And just like with the previous annoyance, Evil also offers an option to change this behavior. If you want to *not* copy the content of a selection you just paste something on top of it, set the variable ~evil-kill-on-visual-paste~ to =nil=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-kill-on-visual-paste nil)
#+end_src

#+begin_center
◆
#+end_center

Because Evil tries to stay faithful to Vim, it does not force Emacs objects into Vim's lingo. One of these examples is the visual selection. Emacs has something called /regions/ that serves, also, to the purpose of selecting text, but in reality, the Vim's visual selection and Emacs' regions, are not the same thing.

However, Evil is an Emacs package, and it also tries to integrate with existent packages and features, and it offers a configuration that makes Evil visual selection, to expand the Emacs selection region when we select something. The net effect of this, is that we can use the terms selection and region interchangeability for all practical purposes.

If you want Evil to synchronize its visual selection with the Emacs region, set the variable ~evil-visual-region-expanded~ to a non-=nil= value:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq evil-visual-region-expanded t)
#+end_src

#+begin_center
◆
#+end_center

Evil defines the priority of its highlight in a way that Emacs displays the visual selection overlays bellow search highlights. As of today I can't figure out why this is the case. One workflow pretty common is to search the name of a variable, select its prefix, and search for the rest of the variable. With the default configuration, you can't see what you're selecting until your selections is bigger than the search term.

Unfortunately, Evil hard-code the [[https://github.com/emacs-evil/evil/blob/master/evil-states.el#L624][visual]] [[https://github.com/emacs-evil/evil/blob/master/evil-states.el#L731][priority]] value to 99 for visual selection, which is smaller than the other hard-coded values for the [[https://github.com/emacs-evil/evil/blob/master/evil-search.el#L666][search]] [[https://github.com/emacs-evil/evil/blob/master/evil-search.el#L868][highlight]] overlays, and this was already reported to Evil on issue [[https://github.com/emacs-evil/evil/issues/1089][#1089]] on GitHub.

To fix this, we have to advise ~evil-visual-highlight~ and ~evil-visual-highlight-block~ to bump the overlay priority after these functions execute:

#+caption: autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-evil-visual-highlight-a (&rest _)
  "Make the visual overlay have higher priority than the search highlight."
  :after '(evil-visual-highlight evil-visual-highlight-block)
  (when evil-visual-overlay
    (overlay-put evil-visual-overlay 'priority 1010))
  (when evil-visual-block-overlays
    (dolist (overlay evil-visual-block-overlays)
        (overlay-put overlay 'priority 1010))))
#+end_src

#+begin_center
◆
#+end_center

Vim (therefore also Evil) has this notion of a grammar to execute actions on text:

#+begin_src text :tangle no
{operation}{operator}{target object}
#+end_src

Where /operation/ is the command you're executing, operator can be /i/ (inside) or /a/ (also), and the /target object/ can be any of the targets defined Evil (e.g. /s/ for /sentence/, /p/ for /paragraph/, /[/ for /square brackets content/, etc. ).

One of these target object is /w/ for /word/ and in my experience, the meaning of /"word"/ varies according to context. Let me explain...

If you're editing a text file for blog, the meaning of /"word"/ is most likely the same meaning of the English dictionary, but if you're editing a /Lisp/ code, a word probably include more characters than the conventional /"word"/ (e.g. while /"foo"/ is a word in any context, /"foo-bar"/ is a word, probably only when you're editing a Lisp file).

A quick trick to make Evil understand the meaning of /"word"/ as I just described, is to create an alias for the function ~forward-evil-symbol~, and name it ~forward-evil-word~. This way, we override the normal function to act as if it is the ~forward-evil-symbol~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defalias #'forward-evil-word #'forward-evil-symbol)
#+end_src

** Text snippets
Snippets (also known as Live Templates on certain platforms), are tidbits of text that one can include on the editing text by typing a keyword and pressing a shortcut key (usually =TAB=) with the cursor right after the keyword.

Doom Emacs offers basic configuration for the package /[[https://github.com/joaotavora/yasnippet][Yasnippet]]/, which is the most used snippet system on Emacs.

Most snippet frameworks available across editors (including /Yasnippet/) offer the ability to edit some placeholders on the snippet, so one can have a single snippet and use it on different scenarios. For instance:

Let's assume I'm a Java developer, and as such, one of the most common scenarios is for me to create a class, more or less like this:

#+begin_src java :tangle no
public class MyClassName {
    public MyClass() {
    }
}
#+end_src

I could make this text as a snippet, and I would have to replace =MyClassName= with whatever name I want, but I could go a step further and make my snippet something like this:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1() {
        $0
    }
}
#+end_src

Now, when I expand this snippet, I have the chance to type the name of the class right after expanding it, press =TAB= again, and get my cursor inside the public constructor.

For instance, first I type the snippet keyword (the =|= character represents the cursor, and =[]= represents a selected placeholder):

#+begin_src java :tangle no
myclass|
#+end_src

As soon as I press =TAB=, the snippet expansion happens:

#+begin_src java :tangle no
public class [|MyClassName] {
    public MyClassName() {

    }
}
#+end_src

If I type a different name for the class, the constructor will mirror that change:

#+begin_src java :tangle no
public class AwesomeClass| {
    public AwesomeClass() {

    }
}
#+end_src

And as soon as I press =TAB= again, the cursor moves to inside the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

Another functionality provided by the snippet framework, is the ability to delete a placeholder that does not make sense on the current context. As an example, lets augment our previous snippet with the ability to type arguments on the constructor:

#+begin_src java :tangle no
public class ${1:MyClassName} {
    public $1(${2:args}) {
        $0
    }
}
#+end_src

Now, after renaming the class, if I press =TAB=, I have the chance to type anything as an argument tot the constructor:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass([|args]) {

    }
}
#+end_src

If I press =TAB= without typing anything, I would move the cursor to inside the constructor, but would have the word =args= as a parameter definition (which, in Java, is not a valid declaration):

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass(args) {   // <-- Compile error
        |
    }
}
#+end_src

What we want to do here, is to delete the placeholder and move to the next position, and end up with the same result as before:

#+begin_src java :tangle no
public class AwesomeClass {
    public AwesomeClass() {
        |
    }
}
#+end_src

By default, we can achieve this by pressing =DEL= instead of =TAB=. In general, this behavior is pretty good, except when you're typing on a MacBook laptop keyboard. MacBook's keyboards don't have the key =DEL= on them, and to get a =DEL=, I have to use a combination of two keys.

For this reason, I want to make sure that the same behavior I have with =DEL=, I also have with =BACKSPACE=.

The following function, is an adaptation of the Doom's own ~+snippets/delete-forward-char-or-field~ function, but doing the reverse of it.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-snippets-delete-backward-char-or-field (&optional field)
  "Delete backward, or skip the current field if it's empty.

Prevents Yas from interfering with backspace deletion."
  (interactive)
  (let ((field (or field (and (overlayp yas--active-field-overlay)
                              (overlay-buffer yas--active-field-overlay)
                              (overlay-get yas--active-field-overlay 'yas--field)))))
    (cond ((not (yas--field-p field))
           (call-interactively #'delete-backward-char))
          ((and (not (yas--field-modified-p field))
                (eq (point) (marker-position (yas--field-start field))))
           (yas--skip-and-clear field)
           (yas-next-field 1))
          ((eq (point) (marker-position (yas--field-start field))) nil)
          ((call-interactively #'delete-backward-char)))))
#+end_src

With the function defined, I can simply add it to a key bind to start using it. Notice on the following code, that I also map =⌘-RET= to allow me to end the snippet completion and accept all the default values (I'm trying to make =⌘-RET= a standard keymap that means /finish and accept/):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after yasnippet

      (:leader :prefix ("h" . "help")
       :desc "Show snippets" :n "y" #'yas-describe-tables)

      (:map yas-keymap
       :g [backspace] #'my-snippets-delete-backward-char-or-field
       :g [deletechar] #'+snippets/delete-forward-char-or-field
       :g [s-return] #'yas-exit-snippet))
#+end_src

The last configuration for snippets is to guarantee the ~yas-describe-tables~ shows up on the right side of the screen:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*YASnippet Tables\\*"
  :slot 2   :vslot -1     :side 'right   :width 104 :height 0.4
  :select t :modeline nil :autosave nil  :ttl 0     :quit t)
#+end_src

Throughout this document, you will find helpful snippets I like to define for certain features. I decided to spread the snippets across different features because I want to indicate to the reader to consider the snippet in question as an integral part of the configuration at hand.

** Inline completion

I add the TabNine autocompletion framework too, for some private AI goodness.

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! company-tabnine)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! company
  (setq +lsp-company-backends '(company-tabnine :separate company-capf company-yasnippet))
  (setq company-show-numbers t)
  (setq company-idle-delay 0)
)
#+end_src

** Spelling

I remove spelling as it isn't needed for me.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'spell-fu-mode)
#+end_src

** Automatic indentation
This is too aggressive so I removed it.

** Smart backspace
As part of my day job, I had to do a lot of Android development, and inevitably I used [[https://www.jetbrains.com/][JetBrains]]
IDE [[https://www.jetbrains.com/idea/][IntelliJ IDEA]]. I bring this up not to chastise who uses or to complain about it. In face, IntelliJ the best IDE for Java and Kotlin out there. It has some features that are so good, that I want to implement on any text editor I use. One of these features is what I call /Smart Backspace/.

On both, Doom and IntelliJ, when you type an open pair, the editor completes with the closing one:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

Also, when you press =<ENTER>=, the editor position the cursor on a newly inserted line, on using the correct indentation, and it also inserts a '=\n=' character after cursor. The result of these actions would be like this:

#+begin_src kotlin :tangle no
fun foo() {
    |
}
#+end_src

The difference between both editors happens when you press =<BACKSPACE>= at this point. While in Doom, this operation would result in:

#+begin_src kotlin :tangle no
fun foo() {
|
}
#+end_src

On IntelliJ, it results in:

#+begin_src kotlin :tangle no
fun foo() {|}
#+end_src

But what happened here?

IntelliJ was able to figure out that, since I was on the indent column of the line *and* I haven't typed anything after the auto-pair, when I pressed =<BACKSPACE>=, my intention was to get back to the state I was before pressing =<ENTER>=, therefore the name I gave to this feature: /Smart backspace/.

To achieve the same result with Doom, we have to add a function advice to delete advice Doom adds to Emacs (the ~+default--delete-backward-char-a~ advice is what is responsible to balance the blank characters you enter after a pair completion).

Our advice function checks if our cursor is position on the expected position to revert the =<ENTER>= pressed between the two pairs. If it is, we remove all the characters before the cursor on the current line. This will put the cursor on a position that Doom's advice function can remove the two new line characters around the cursor, putting the buffer on the same state we were before we pressed =<ENTER>=:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-super-backward-delete-a (&rest _)
  "Special function to super-delete things.

If the line content before cursor contains only blank characters, this function
will delete all the blank characters, and then, join with the previous line. I
there is any non-blank character before cursor, this function will delete the
entire line, but keep the correct indentation on it."
  :before '+default--delete-backward-char-a
  (let* ((line-pos (- (point) (point-at-bol)))
         (prev-indent (save-excursion
                        (forward-line -1)
                        (current-indentation)))
         (prev-line-bol (point-at-bol 0))
         (next-line-eol (point-at-eol 2))
         (smart-bs-p (or (save-excursion
                           (and (re-search-backward "{[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*}" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "\\[[ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*\\]" next-line-eol t)))
                         (save-excursion
                           (and (re-search-backward "([ \t]*\n[ \t]*" prev-line-bol t)
                                (re-search-forward "[ \t]*\n[ \t]*)" next-line-eol t))))))
    (when (and smart-bs-p
               (<= line-pos (+ prev-indent standard-indent)))
      (delete-char (- line-pos)))))
#+end_src

Adding this advice as an /autoload/ function on our configuration is all we need to get the functionality working. When Doom loads the ~smartparens~ on the default module, it replaces the Emacs ~delete-backward-char~ function with its ~+default--delete-backward-char-a~ advice, which will load our function, which, in turn, installs itself as a =:before= advice on Doom's function.

** Balanced pairs
I handle this with =company-tabnine= now.

** Useful line numbers
A long time ago, I read on some Vim mailing list, an opinion on how line numbers should behave on different editing modes (if you know who is the original author of such idea, please let me know, so I can give credit where credit is due). Since on normal mode is pretty useful to know the line count from the cursor until some target text, it makes more sense to have the =relative number= shown on the gutter, but when I'm editing the buffer, is nice to have a sense of size by looking to the line numbers.

So, I can describe this behavior as follows:

- When on normal mode, show relative line numbers;
- When on insert mode, show absolute line numbers;

To achieve this, I need a function that turns the /absolute/ line number when line numbers are visible:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-absolute-h ()
  "If line numbers are visible, set the current line number type to `absolute.'"
  (if display-line-numbers
      (setq display-line-numbers t)))
#+end_src

And another function to put the line numbers on /relative mode/ (but again, only if line numbers are visible):

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-line-number-visual-h ()
  "If line numbers are visible, set the current line number type to `visual'"
  (if display-line-numbers
      (setq display-line-numbers 'visual)))
#+end_src

With those functions created, after loading Evil, I can hook them to a mode switch:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook! '(evil-emacs-state-entry-hook
               evil-insert-state-entry-hook) 'my-line-number-absolute-h)
  (add-hook! '(evil-emacs-state-exit-hook
               evil-insert-state-exit-hook) 'my-line-number-visual-h))
#+end_src

To finalize, I want to make line numbers visible on any programming mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (setq-hook! 'prog-mode-hook display-line-numbers-type 'visual))
#+end_src

** Ruby Indenting

I don't agree with the ruby indenting rules, and ruby-mode lets us customise with some variables.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq ruby-align-to-stmt-keywords 't
      ruby-align-chained-calls nil
      ruby-block-indent nil)
#+end_src

** Auto-Saving
First of all, since I'm going to save my work constantly, I don't want Emacs to ask me if it should really exit, or if it should kill outstanding processes while doing it. For me, if I'm telling Emacs to quit, I want it to do it, regardless its state, but I don't want to lose any content of my current work. So, the first thing I'm going to do, is to disable questions when I'm quitting Emacs:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq confirm-kill-emacs nil
      confirm-kill-processes nil)
#+end_src

Emacs allows you to define some /advices/ to any function you want. This allows you to hook some code when the user, or the system calls such functions. On the case of aggressive auto-save, I want Emacs to save any content when I try to close the buffer associated with the content, of if I'm trying to quit Emacs. To do so, I'll create an /autoload/ advice to perform such work:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defadvice! my-save-all-buffers-a (&rest _)
  "Advice to run `save-some-buffers' before a function.

This is a part of the full auto-save feature."
  :before (list #'save-buffers-kill-emacs #'my-tabs-close-buffer-tab)
  (save-some-buffers t nil))
#+end_src

And to wrap up this configuration, I enable the auto-save mode:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(auto-save-visited-mode 1)
#+end_src

Call the same advice as a normal function when Emacs executes the auto-save hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! 'auto-save-hook #'my-save-all-buffers-a)
#+end_src

And add the advice function to the ~after-focus-change-function~ as well, just to make sure Emacs save any outstanding buffer as soon as possible if it loses focus:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-function :after after-focus-change-function #'my-save-all-buffers-a)
#+end_src

This aggressive auto-save will work as expected, but it will crate a side effect with my literate configuration. Since Doom tangles the Org file every time we save it, the aggressive auto-save will make this tangle happen more often than we want.

Doom documentation offers a partial solution to this problem asking us to remove the auto-tangle function from the save hook, so let's do it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'org-mode-hook #'+literate-enable-recompile-h)
#+end_src

Another core behavior that does not play well with my aggressive auto-save configuration is how Doom configures ~ws-butler~. While I understand the rationale behind the choice of always remove blank spaces regardless the cursor position, I rather the plugin to not remove blank spaces before the cursor.

To adjust that, let's make ~ws-butler~ behave how I expect it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! ws-butler
  (setq ws-butler-keep-whitespace-before-point t))
#+end_src

** Persist frame position and geometry
Before I start tackling my own requirement, let's make Emacs /remember/ its window size and position between launches.

First, I like to define an autoloaded function to hook into the Emacs kill process to save frame dimensions. The reason to get an autoload function, is to allow Emacs to *not* load it until it really needs it, which would be when I'm quitting Emacs.

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-save-frame-dimensions-h ()
  "Caches the current frame dimensions and position."
  (if-let ((main-frame (car-safe (visible-frame-list))))
      (doom-store-put 'last-frame-size
                      (list (frame-position main-frame)
                            (frame-width main-frame)
                            (frame-height main-frame)
                            (frame-parameter main-frame 'fullscreen)))))
#+end_src

Then, I like to have the analog function to call when we create a frame:

#+caption: $DOOMDIR/autoload/editor.el
#+begin_src emacs-lisp :tangle autoload/editor.el
;;;###autoload
(defun my-restore-frame-dimensions-h ()
  "Restore frame dimensions and position from `my-save-frame-dimensions-h'."
  (if-let (dims (doom-store-get 'last-frame-size "default"))
      (cl-destructuring-bind ((left . top) width height fullscreen) dims
        (setq initial-frame-alist
              (append initial-frame-alist
                      `((left . ,left)
                        (top . ,top)
                        (width . ,width)
                        (height . ,height)
                        (fullscreen . ,fullscreen)))))
    (add-to-list 'default-frame-alist '(height . 40))
    (add-to-list 'default-frame-alist '(width . 140))))
#+end_src

With the function defined, I just need to connect them to the correct hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'kill-emacs-hook #'my-save-frame-dimensions-h)
(my-restore-frame-dimensions-h)
#+end_src

** TODO Remote editing
TBD (still need to figure out the best way to address this).

* Personal preferences
This section will show the reader, some of the small changes I decided to implement on Doom related to Evil, my personal keybindings, my choice of appearance, and other personal configurations. All in all, is pretty safe to skip this section if you intend to implement your own customization.

** Evil
For most of it, Doom integration of Evil is pretty amazing, I found just one package I don't use (or don't want to use at all), two configurations that I want to do some adjustments, and three packages missing.

The package I don't use is ~evil-escape~, and its purpose, is to allow one to type =j k= fast enough on insert mode to force moving from insert mode to normal mode.

If you're used to this feature, good for you, but I was never able to adjust my muscle memory to it, so I rather disable it on =packages.el=:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

The first Evil configuration I want to adjust to my liking is on ~evil-goggles~. I understand Henrik (Doom's creator) has a good rational on why he set up ~evil-goggles~ the way it is, but I like the original design where *all* changes get the highlight treatment.

Also, I use ~evil-cleverparens~, and its editing operations are not configured on ~evil-goggles~, so, in order to make it work for me, I have to do two things:

1. Re-enable the change feedback disabled by default on Doom;
2. Add all ~evil-cleverparens~ commands to the ~evil-goggles--commands~ to allow ~evil-goggles~ to handle changes from those commands as well.

I can perform those changes using ~use-package~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-goggles
  :hook (doom-first-input . evil-goggles-mode)
  :config
  (setq evil-goggles-duration 0.15
        evil-goggles-enable-delete t
        evil-goggles-enable-change t)

  (pushnew! evil-goggles--commands
            '(evil-cp-delete
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-line
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--delete-line-advice)
            '(evil-cp-delete-sexp
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-delete-enclosing
              :face evil-goggles-delete-face
              :switch evil-goggles-enable-delete
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-yank
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-line
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-sexp
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-yank-enclosing
              :face evil-goggles-yank-face
              :switch evil-goggles-enable-yank
              :advice evil-goggles--generic-async-advice)
            '(evil-cp-change
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-line
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-sexp
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-cp-change-enclosing
              :face evil-goggles-change-face
              :switch evil-goggles-enable-change
              :advice evil-goggles--generic-blocking-advice)
            '(evil-paste-after
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)
            '(evil-cp-copy-paste-form
              :face evil-goggles-paste-face
              :switch evil-goggles-enable-paste
              :advice evil-goggles--paste-advice
              :after t)))
#+end_src

After this I can sneak a quick modification to allow ~evil-goggles~ to use the same faces used on =diff=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil-goggles
  (evil-goggles-use-diff-refine-faces))
#+end_src

The second configuration is regarding centralizing the cursor after search jumps. I find myself pretty uncomfortable after I press =n= following a search term, and I figured it out that what makes me uncomfortable is the fact the cursor is at the bottom of the screen, and I have almost no visibility of the text after it.

To fix this, I will add an advice after the Evil search function used to perform those jumps, to recenter the cursor on the window:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-center-after-jump-a (&rest _)
  :after 'evil-ex-search
  (evil-scroll-line-to-center nil))
#+end_src

And to make this behavior more consistent throughout the editor, I will add the same function used to advise ~'evil-ex-search~ as a hook to the ~evil-jumps-post-jump-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (add-hook 'evil-jumps-post-jump-hook #'my-center-after-jump-a))
#+end_src

And finally, for the packages I'm missing, they are:

- ~evil-matchit~
- ~plus-minus~
- ~evil-string-inflection~

*** Evil-MatchIt
In all fairness, ~matchit~ (the one originally from Vim) is also disabled by default, but it provides such useful feature that I can't understand why it is not part of the standard Vim/Evil.

To the reader not familiar with this plugin, let me give a brief overview of it. You probably know that pressing the key =%= on a pair of character (e.g. =(=, =)=, =[=, =]=, etc.), makes the cursor jump to the other pair.

The ~matchit~ plugin, extends this functionality to other types of pairs, like XML/HTML tags, language control flows like =if=, =else=, and =endif=, and others. So, as I said, a pretty useful plugin!

Since [[https://github.com/redguardtoo/evil-matchit][~evil-matchit~]] is not distributed with Doom, I need to bring its package in:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-matchit)
#+end_src

Then, need to make sure to enable the plugin itself. In order to not slow the Emacs startup, I will enable it after I load the first file into a buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! evil-matchit
  :hook (doom-first-file . global-evil-matchit-mode)
  :init
  (setq evilmi-quote-chars (string-to-list "'\"/")))
#+end_src

*** Plus-Minus
[[https://github.com/peterwu/plus-minus][~plus-minus~]] is a package that provides the functionality to increase or decrease a number value at point. On Vim, the key bindings for these actions are =C-a= and =C-x= respectively.

I spend too much time thinking that I should preserve the =C-x= keybinding for Emacs' sake, and I learn to use a command or two that uses it, but the reality is that I don't really need it, so I will give it a try on rebinding this key to its original Vim purpose, but instead of using ~evil-numbers~ (which Doom provides as a core package), I'll try a brand-new package called ~plus-minus~:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! evil-numbers :disable t)

(package! plus-minus
  :recipe (:host github
           :repo "peterwu/plus-minus"))
#+end_src

Since this package provides the correct ~autoloads~ on it, I can simply configure it to get deferred until I actually need it:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! plus-minus :defer t)
#+end_src

Before defining the keybindings for this I would like to have an extra behavior when I try to increase or decrease a number at point. I would like to rotate the text at point with the same keybinding if the /thing at point/ is not a number.

Doom ships with the ~rotate-text~ package by default, but I need couple helper functions to define which package should handle the key press:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-inc-or-rotate-at-point (arg)
  "Try to rotate or increase the text at point.

If the thing under cursor is not rotated, tries to increase the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward+) (+/-:forward+))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward+) (+/-:forward+))))))
#+end_src

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-dec-or-rotate-at-point (arg)
  "Try to rotate or decrease the text at point.

If the thing under cursor is not rotated, tries to decrease the number at
`point' or the first number from `point' to `point-at-eol'.

When called with ARG (by using the universal prefix key) the search for a number
happens from `point' to `point-at-bol'."
  (interactive "p")
  (if (thing-at-point 'number)
      (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))
    (condition-case nil
        (rotate-text arg)
      ('error (if current-prefix-arg (+/-:backward- 1) (+/-:forward- 1))))))
#+end_src

And I also like to define some extra words for rotation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! rotate-text
  (add-to-list 'rotate-text-words '("yes" "no"))
  (add-to-list 'rotate-text-words '("allow" "deny"))
  (add-to-list 'rotate-text-words '("allowed" "denyed")))
#+end_src

With all in place, we just need to define the keybindings:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :n "C-a" #'my-inc-or-rotate-at-point
  :n "C-x" #'my-dec-or-rotate-at-point
  (:prefix "g"
    :desc "Inc sequence" :v "=" #'+/-:block+
    :desc "Dec sequence" :v "-" #'+/-:block-
    :desc "Inc sequence" :n "=" #'my-inc-or-rotate-at-point
    :desc "Dec sequence" :v "-" #'my-dec-or-rotate-at-point)
  (:leader
   :desc "Emacs C-x" :n "C-x" ctl-x-map))
#+end_src

In order to allow me to repeat the last increase or decrease, I will define a /repeatable map/ for my custom increase and decrease functions:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-inc-or-rotate-repeat-map
                '((my-inc-or-rotate-at-point . "=")
                  (my-dec-or-rotate-at-point . "-"))
                "Keymap to repeat the last number increase or decrease.")
#+end_src

*** Evil-String-Inflection
I've been on situations where I realized that I used /camelCase/ for all my variables, where the standard coding style of the language, request to use /snake_case/ style. There are packages available, that allow you to cycle through all case styles on a given word.

I found the [[https://github.com/akicho8/string-inflection][~string-inflection~]] package to be one of the best available. There is the package [[https://github.com/ninrod/evil-string-inflection][~evil-string-inflection~ ]]to integrate with Evil, but it turns out to not work as expected, so I will have to configure Evil integration myself. Let's start with the package itself:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection)
#+end_src

As with the ~matchit~ package, I'll defer its loading until we need it, but different from ~matchit~, I have to defer it using an alternative approach. I will make the package load on the first invocation of one of its main commands:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase))
#+end_src

I want to have a rich set of mappings for this package, so I will add one key for each inflection plus a toggle and a cycle:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("g~" . "string inflection")
      :desc "cycle" "~" #'string-inflection-all-cycle
      :desc "toggle" "t" #'string-inflection-toggle
      :desc "CamelCase" "c" #'string-inflection-camelcase
      :desc "downCase" "d" #'string-inflection-lower-camelcase
      :desc "kebab-case" "k" #'string-inflection-kebab-case
      :desc "under_score" "_" #'string-inflection-underscore
      :desc "Upper_Score" "u" #'string-inflection-capital-underscore
      :desc "UP_CASE" "U" #'string-inflection-upcase)
#+end_src

In order to create a nicer workflow, I want to access the previous shortcuts by pressing the same key after the initial inflection. For instance, I want to press =SPC g ~= to start the inflection, and keep pressing just =~= to cycle through all the other inflections.

To achieve this behavior I will use the ~my-repeat-map!~ macro introduced on the section [[Repeatable commands]]:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-string-inflection-repeat-map
                '((string-inflection-all-cycle . "~")
                  (string-inflection-toggle . "t")
                  (string-inflection-camelcase . "c")
                  (string-inflection-lower-camelcase . "d")
                  (string-inflection-kebab-case . "k")
                  (string-inflection-underscore . "_")
                  (string-inflection-capital-underscore . "u")
                  (string-inflection-upcase . "U"))
                "Keymap to repease the last string inflection.")
#+end_src

To make ~string-inflection~ to work nice with Evil, I will create an /Evil operator/ to allow me to change the string inflection of a target text object:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! evil
  (evil-define-operator my-evil-operator-string-inflection (beg end _type)
    "Define a new evil operator that cicles underscore -> UPCASE -> CamelCase."
    :move-point nil
    (interactive "<R>")
    (string-inflection-all-cycle)
    (setq evil-repeat-info (list [?g ?~])))

  (define-key evil-normal-state-map (kbd "g~") 'my-evil-operator-string-inflection))
#+end_src

** Ruby Hash Syntax Toggle

I like to be able to switch between hash syntaxes when fixing old code

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! ruby-hash-syntax)
#+end_src

** Keybindings
Since I decided to write this configuration, I also decided to try to use the standard Doom key bindings as much as possible, and for the most part of it, I'm not having as much problem as I expected. There are three main areas where I still like to define my own bindings.

*** Window navigation
A while ago, I configured Vim to move the cursor from one window to another using the standard movements keys (=h=, =j=, =k=, and =l=) while keeping =Ctrl= pressed. I got so used to these shortcuts, that I can't live without it anymore.

The good news is that, on most cases, there is no conflict between features I use and these shortcuts, and on the cases that a conflict exists, there are reasonable options to work around these limitations.

The first step to achieve a global window navigation shortcuts, is to clean the target keys from any keymap that might bind them to a command:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after outline
  (:map outline-mode-map
   :gn "C-h" nil
   :gn "C-j" nil
   :gn "C-k" nil
   :gn "C-l" nil)))
#+end_src

After that, I can bind these keys to the target window movements to the proper window commands:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
  :gn "C-h" #'evil-window-left
  :gn "C-j" #'evil-window-down
  :gn "C-k" #'evil-window-up
  :gn "C-l" #'evil-window-right)
#+end_src

Some other modes don't play nice with this particular key bindings I choose, and I have to adjust them accordingly. This is the case of the =Info-mode=, where =C-j= and =C-k= are the keys to navigate forward and backwards on nodes. The solution for me is to bind those commands to other keys, and configure the proper window navigation:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after info
      :map Info-mode-map
      :gn "s-k" #'Info-backward-node
      :gn "s-j" #'Info-forward-node
      :gn "C-k" #'evil-window-up
      :gn "C-j" #'evil-window-down)
#+end_src

*** Vim defaults
Here I need to make yet another disclaimer to the reader: I know what I'm about to write is a pet peeve, and most likely most Doom users won't even understand this, but...

On Doom, there are these keymaps bound to =<leader> w ...=, that should match Vim's =<C-w> <C-...>=. Since the /leader shortcuts/ are more ergonomic for me, I got used to them quickly. The problem I have, is the difference between =<C-w> <C-o>= and =<leader> w o=!

To not lose a Doom-only keymap, instead of simply rebinding =<leader> w o= to the /correct/ command, I'll /move/ ~doom/window-enlargen~ to a different keymap (=<leader> w z= to represent /zoom window/), and assign the /correct/ command to the /correct/ keymap:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("w" . "window")
      :desc "Enlarge window"         :n "z" #'doom/window-enlargen
      :desc "Select window"          :n "o" #'delete-other-windows)
#+end_src

*** Personal shortcuts
Key bindings in this section are purely personal choice. Feel free to give them a try if you want, but if you're used to Doom Emacs already, my suggestion is to skip this section.

#+begin_center
◆
#+end_center

The first keymap group I like to add custom shortcuts is the multiple cursors. When I first heard about multiple cursors, was on a demo of the [[https://macromates.com/][TextMate]] editor. I got so impressed by it that this feature was one of the first things I would search on an editor. Fast forwarding to January 2008, I was watching yet another demo of a brand-new editor, when the person showing off the features, demonstrated the multiple cursors. This editor was [[https://www.sublimetext.com][Sublime Text]], and I couldn't resist the chance to give it a try. For reasons of the brain (at least my brain), the shortcuts defined to manipulate multiple cursors got engraved in my memory, and recently, I decide to stop fighting against it and embrace! So these are the shortcuts (which might be different from the current shortcuts in Sublime) that I got /used to/:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 :gn "s-d" #'evil-mc-make-and-goto-next-match
 :gn "s-u" #'evil-mc-skip-and-goto-prev-cursor
 :gn "s-n" #'evil-mc-skip-and-goto-next-match
 :gn "s-g" #'evil-mc-make-all-cursors
 :gn "C-M-k" #'evil-mc-make-cursor-move-prev-line
 :gn "C-M-j" #'evil-mc-make-cursor-move-next-line)
#+end_src

#+begin_center
◆
#+end_center

Another /nice to have/ binding I got used to, is to move blocks of text up and down, using =j= and =k=, plus the =Meta= (a.k.a. =Alt=, =option=, or  =⌥=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :nvi "M-j" #'drag-stuff-down
      :nvi "M-k" #'drag-stuff-up)
#+end_src

#+begin_center
◆
#+end_center

Something that I really like but usually forget to use is the ability to insert a new line while on /insert mode/, above or below the current line, regardless where the cursor is. To use it, I would simply press =<ENTER>= with =<SUPER>= (a.k.a. =cmd= or =⌘=) to insert a line bellow, or =<ENTER>= plus =<SHIFT>= and =<SUPER>= for a line above:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :i [s-return]   #'+default/newline-below
      :i [s-S-return] #'+default/newline-above
      (:when IS-MAC
         :gn "s-RET"        nil
         :gn [s-return]     nil
         :gn "S-s-RET"      nil
         :gn [S-s-return]   nil))
#+end_src

#+begin_center
◆
#+end_center

Doom Emacs, offer a shortcut to bring back the last dismissed popup, which is what I want to do on the majority of the cases. But sometimes, I want to bring back a specific popup buffer to the front, and I like to have a dedicated prefix key to handle this scenario.

For now, I set a shortcut for the =*Messages*=, and the =*Backtrace*= buffers, but more popup buffer might get added here in the future:

#+caption:config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("v" . "view")
      :desc "View Messages" :n "m" #'(lambda ()
                                       (interactive)
                                       (pop-to-buffer "*Messages*")
                                        (goto-char (point-max)))
      :desc "View Backtrace" :n "e" #'(lambda ()
                                        (interactive)
                                        (pop-to-buffer "*Backtrace*")))
#+end_src

As you can see, I also like to /scroll to the bottom/ of the buffer when opening messages. The rationale behind it is the fact that if I want to quick loo into the =*Messages*= buffer, is most likely to check the latest messages there.

Also, for the =*Messages*= buffer, I like to be able to press =q= to quit as well. Unfortunately this is not defined by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map messages-buffer-mode-map
      :n "q" #'delete-window)
#+end_src

#+begin_center
◆
#+end_center

One binding I feel is missing on Doom, is the ability to evaluate any sexp on *any* mode, like a /global/ ~eval-last-sexp~. Gladly, it's easy enough to create my own:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :prefix "g"
      :desc "Eval last sexp" :n ")" #'eval-last-sexp)
#+end_src

#+begin_center
◆
#+end_center

I don't remember when this shortcut entered my life, but some time ago I got used to using =s-RET= to /confirm operations/ like sending emails and messages. In order to try to replicate this behavior I will start setting it to the ~with-editor-mode-map~ together with the analog cancel operation with =s-ESC= shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :map with-editor-mode-map
      :in [s-return] #'with-editor-finish
      :in [s-escape] #'with-editor-cancel)
#+end_src

#+begin_center
◆
#+end_center

Doom ships with the /Rainbow Mode/ package, which is a package that colorizes strings that represent colors. Usually there is no need to enable this mode globally because the colorization might get in the way of legibility, but on the cases where it is useful (e.g. editing CSS or Android XML files), it is *really* useful.

Because of this, I want to set this mode as a toggable shortcut:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :leader :prefix ("t" . "toggle")
      :desc "Rainbow mode" :mvn "R" #'rainbow-mode)
#+end_src

*** Repeatable shortcuts
Due to the nature of modal edit, some shortcuts need more than one key press to activate. This is usually fine until we try an action designed to repeat (e.g. side scroll and window resizing). This section will use the ~my-repeat-map!~ macro defined on the [[Repeatable commands]] sections to make these actions more ergonomic.

#+begin_center
◆
#+end_center

The first candidate for a repeatable pattern is window resizing. On Vim (and also Evil) for instance, the key binding to increase height is =C-w +=. Doom makes this a little bit better by making all key bindings from =C-w= accessible with the prefix =SPC w=, but still, adjusting the size of a window with multiple keystrokes like this, is a bad experience.

We can make the window resizing commands safe to repeat, which would allow us to repeat the last resizing with the =.= repeat operator. The problem with this approach, is the fact that we can /change directions/ when repeating the resize. For instance, if we are increasing the height of a window, and we press the =.= couple more times we wanted, to decrease its size, we would have to start over with the decrease command and pay attention to not get it wrong this time.

To avoid this issue, I will define a /repeatable map/ for resizing, and because this is a separate map from the normal window map, I can add couple extra keys there to make the operation even smoother, for instance, we can increase the window height with =+= or with the === key

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-window-resize-repeat-map
                '((evil-window-increase-height . "+")
                  (evil-window-increase-height . "=")
                  (evil-window-decrease-height . "-")
                  (evil-window-decrease-height . "_")
                  (evil-window-increase-width . ">")
                  (evil-window-decrease-width . "<"))
                "Repeatable map for window resizing")
#+end_src

#+begin_center
◆
#+end_center

Sometimes you're editing a buffer on a window that requires you to scroll to the right and left to read its content. You can achieve that by pressing =z l= to scroll to the right, and =z h= to scroll to the left. While this is ok, besides enabling to repeat this motion with just an =l= or an =h= after the initial scroll, I also want to jump longer distances (the default is to move one character on each =z l= or =z h= shortcuts). To jump more than one character, I need to create a wrapper function that passes a bigger number to the ~evil-scroll-column-right~ or ~evil-scroll-column-left~ functions:

#+caption: autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-big-scroll-column-right ()
  "Wrapper for the `evil-scroll-column-right' that passes 10 as the jump size."
  (interactive)
  (evil-scroll-column-right 10))

;;;###autoload
(defun my-big-scroll-column-left ()
  "Wrapper for the `evil-scroll-column-left' that passes 10 as the jump size."
  (interactive)
  (evil-scroll-column-left 10))
#+end_src

And with those helper functions I can define the proper /repeatable map/ for side scrolling:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-repeat-map! my-side-scrolling-repeat-map
                '((evil-scroll-column-right . "l")
                  (my-big-scroll-column-right . "L")
                  (evil-scroll-column-left . "h")
                  (my-big-scroll-column-left . "H"))
                "Repeatable map to scroll the buffer left or right.")
#+end_src

** Appearances
As far as I understand, there is a share of Emacs users that value Emacs functionalities over its looks, and I would like to write something targeted for those users.

You are awesome! I can't imagine how liberating it would feel if my brain did not obsess about my editor's appearance, so, stay strong folks! The breakthroughs on technology happen more often by the desire of people like you then people like me.

With that out of the way, I need to explain to the reader my personal position on this subject. As a person with [[https://en.wikipedia.org/wiki/Attention_deficit_hyperactivity_disorder][ADHD]] and [[https://en.wikipedia.org/wiki/Obsessive%E2%80%93compulsive_disorder][OCD]].

Look, mate. There is not much else to say, but if you need a bit more let me say this: When your brain is constantly searching for dopamine, and is incapable to retain it for much longer, every tinny rewarding counts towards the goal to keep my focus on one subject. If my work environment is pleasing to look, there is a lower chance my brain gets distracted by the scene outside the window. If I open my editor and get the feeling of /"oh yeah"/, then my brain will look forward to using the same tool again, or as I saw on this [[https://twitter.com/ADHDelaide/status/1326412306079682560][tweet]] a while ago, and reproduce it here for you:

#+begin_quote
❝ Having *ADHD* is basically finding new ways to trick your brain into doing the stuff you want it to do, until you die. ❞
─ *@ADHDelaide*
#+end_quote

Nevertheless, keep in mind that taste, is a personal thing. What I consider to be beautiful, might look horrendous to the reader, and that is OK.

So, if you're happy with the look and feel of your editor, feel free to skip this entire section.

*** Frame

The Emacs frame is the container for my small world, and although I intend to do most of my things within Emacs, I still want it to look like it belongs to its environment (macOS in my case), and there are couple things I like to change to make it more macOS.

The first one is to remove the text from the title bar. On macOS, the application name is present on the system menu, so there is no reason to keep any text on the title bar:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq frame-title-format nil
      ns-use-proxy-icon nil)
#+end_src

And the second one, is to make the title bar to have the same color as the background of my selected theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

*** Editor

The first thing to do to help with my editor appearance, is to store the current line height in a variable. This way, other adjustments can use this value without worrying about different font sizes:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defvar my-line-pixel-height (line-pixel-height)
  "Line height in pixels.

Used to avoid getting the wrong line height when `text-scale-mode' is active.")
#+end_src

One editor visual I like to have while I'm coding, is the ~fill-column-indicator~. Unfortunately I discovered that on macOS, the default ~fill-column-indicator~ face, can't render Unicode characters properly. The workaround here is to make this particular face to use a font that can render them:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-face-attribute 'fill-column-indicator nil
                    :font "Arial Unicode MS"
                    :height 140
                    :foreground (doom-color 'base3 256))
#+end_src

Using /Arial Unicode MS/ allow me to use the "=┊=" character to decorate my ~prog-mode~ buffers. After setting this up, I need to adjust the ~fill-column~ value to the column I want (while is usually 100), and make the column indicator use the correct Unicode character (which is =0x9482=):

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq-default fill-column 100
              display-fill-column-indicator-column 100
              display-fill-column-indicator-character 9482)
#+end_src

After this configuration I want to make sure the column indicator is off by default:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(global-hl-line-mode -1)
#+end_src

And enabled on all ~prog-mode~ buffers:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
#+end_src

#+begin_center
◆
#+end_center

As with column indicator, there is another visual that I consider crucial for programming, but a bit annoying when writing prose: The current line highlight.

I can't imagine coding without it, but when I'm writing, it becomes more a distraction then an aid.

On Doom, to make sure current line highlight gets disabled, you need to remove its global mode from the ~doom-first-buffer-hook~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook 'global-hl-line-mode)
#+end_src

Then, I can add the mode to all ~prog-mode~ buffers with another hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'hl-line-mode)
#+end_src

#+begin_center
◆
#+end_center

Another extra for the editor visuals is rendering the character =^L=, which represents a page break (more precisely, the /form feed/ character).

The page break character is considered a /space/ or /empty/ character, which allows one to add it on a coding file without breaking the build for such file.

There are a couple packages that achieve this goal, but I set on the [[https://github.com/purcell/page-break-lines][~page-break-lines~]] from [[https://github.com/purcell][Steve Purcell]] because he chose to implement this feature using glyph composition instead of /font-lock/:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines)
#+end_src

There is just one configuration I prefer to change over the defaults, which is the size of the horizontal line. I like the horizontal like to stop at the ~fill-column~ column, which gives this nice /box feeling/ to the code.

Besides this change, I only enable the mode on ~prog-mode~ buffers, and I like to define a shortcut key to jump to the next or previous page break:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! page-break-lines
  :hook ((prog-mode . page-break-lines-mode))
  :init
  (setq page-break-lines-max-width fill-column)

  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

#+begin_center
◆
#+end_center

Since the time when widescreen monitors became the standard, when it comes to split windows in two, I prefer horizontal splits (one window aside of the other). In order to tell Emacs that I prefer horizontal splits, I have to set the width split threshold to a small number to add weight on Emacs' decision of which orientation to split:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq split-width-threshold 40)
#+end_src

*** Theme
I decided to give /Doom-Palenight/ a try, and so far I'm enjoying. I will admit that the purplish feeling of the palette is not my style, but overall, I'm not finding a bed choice.

So, to make /Doom-Palenight/ the default theme, set the variable ~doom-theme~ to the symbol ='doom-palenight= to let Doom know what is the theme it should load:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-theme 'doom-palenight)
#+end_src

And because I like visual cues on my editor, I will turn on the ability to display *bold* and /italic/ faces for the theme:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-themes-enable-bold t
      doom-themes-enable-italic t)
#+end_src

*** Typography
:PROPERTIES:
:CUSTOM_ID: prefs-typography
:END:
This section requires an important disclaimer to the reader. In the majority of the cases, one should not /need/ to customize their fonts the way I'm doing it. Doom Emacs has a system to configure the editor fonts, and one should prefer to use such systems instead of this particular configuration.

Doom exposes five (optional) variables for controlling fonts:

- ~doom-font~ :: The global font used by Emacs;
- ~doom-big-font~ :: Used for ~doom-big-font-mode~, which you can use for presentations or streaming;
- ~doom-variable-pitch-font~ :: Font used for prose text (if you configure such modes to accept variable pitch fonts);
- ~doom-serif-font~ :: The default font to use for the fixed-pitch-serif face;
- ~doom-unicode-font~ :: Fallback font for Unicode glyphs;

They all accept either a font-spec, a font string (e.g. "Input Mono-12"), or a =xlfd= font string. You generally only need ~doom-font~ and ~doom-variable-pitch-font~, but I like to set ~doom-big-font~ as well, to make sure any time I switch to a presentation mode, it still feels like I have the same editor, but with a bigger font.

With that out of the way, I need to explain what is, and why my /typography/ configuration exists.

#+begin_center
◆
#+end_center

In the past years, I've got involved in some projects where I worked directly with the UX team on visual identity tasks. One of the first thing I got used to doing, is to define the typography of the project. But what is typography? According to the Wikipedia:

#+begin_quote
*Typography* is the art and technique of arranging type to make written language legible, readable and appealing when displayed.
#+end_quote

In the case of my configuration, I can define typography as a set of rules regarding displayed text that I want to use regardless the mode Emacs is in. Or simply put:

Text in my editor must be consistent, and look good.

To achieve this, I have to define said rules, and create a mechanism that will help me get the editor to behave the way I want. The one exception are the colors used on text elements. I want to let this particular trait to the theme I'm using.

The first rule to define is the simplest one: which fonts to use throughout the editor.

Currently, I narrowed my selection to these 2 fonts:

- JetBrains Mono
- Iosevka-Aile

Shamelessly copied from [[https://systemcrafters.net/emacs-tips/presentations-with-org-present/][System Crafters]]

No need to install them, my nix setup handles that. It grabs them from Homebrew.

The rest of the rules are more subjective, and in all honesty, the methodology I used to decide which slant, and weight to use to each one of the text elements is non-existent. I simply tried, checked how it looked, and asked myself, /"Is this a nice looking element?"/. If the answer was yes, I kept the configuration.

For the size, I started with the headline level 1 and configure it to be as big as it could be without looking disproportional to the text. Then, I reduced the size for the next level gradually until I get to the 8^{th} one, guaranteeing that it would not be smaller than the normal font size.

In practice, this means:

#+caption: Headline sizes and multipliers
#+name: tbl:typ-heads
| Headline Level | Proportional size | Multiplier |
|----------------+-------------------+------------|
| Level 1        |              100% |        2.0 |
| Level 2        |               80% |        1.8 |
| Level 3        |               60% |        1.6 |
| Level 4        |               40% |        1.4 |
| Level 5        |               30% |        1.3 |
| Level 6        |               20% |        1.2 |
| Level 7        |               10% |        1.1 |
| Level 8        |                0% |        1.0 |

To make my typography rules easy to refer to, I create one face for each rule as follows:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(defface my-default-mono `((t :font ,(font-spec :family "JetBrains Mono"
                                                :size 16
                                                )))
  "Default monospaced font used on majority of the buffers."
  :group 'my-typography)

(defface my-big-face-mono `((t :font ,(font-spec :family "JetBrains Mono"
                                                 :size 26
                                                 )))
  "Monospaced font used on presentation mode."
  :group 'my-typography)

(defface my-default-ui `((t :font ,(font-spec :family "JetBrains Mono"
                                              :size 16
                                              )))
  "Extra face used on UI elements."
  :group 'my-typography)

(defface my-ui-window-header `((t :inherit my-default-ui
                                  :height 0.8))
  "Face used on decorative buffer headers."
  :group 'my-typography)

(defface my-default-prose `((t :font ,(font-spec :family "Iosevka Aile"
                                                 :size 18
                                                 :weight 'light)))
  "Default variable pitch font used on prose writing."
  :group 'my-typography)

(defface my-document-title `((t :inherit my-default-prose
                                :height 2.4
                                :weight light
                                :slant normal))
  "Face used for document titles."
  :group 'my-typography)

(defface my-headline-1 `((t :inherit my-default-prose
                            :height 2.0
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-2 `((t :inherit my-default-prose
                            :height 1.8
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-3 `((t :inherit my-default-prose
                            :height 1.6
                            :weight semi-light
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-4 `((t :inherit my-default-prose
                            :height 1.4
                            :weight semi-light
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-5 `((t :inherit my-default-prose
                            :height 1.3
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-6 `((t :inherit my-default-prose
                            :height 1.2
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-7 `((t :inherit my-default-prose
                            :height 1.1
                            :weight bold
                            :slant normal))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-headline-8 `((t :inherit my-default-prose
                            :height 1.0
                            :weight bold
                            :slant italic))
  "Face used for headlines of level 1."
  :group 'my-typography)

(defface my-uri-face `((t :inherit link))
  "Face used to display URIs."
  :group 'my-typography)
#+end_src

The goal is to customize the fonts I want to have follow one of these rules by resetting all its values to ='unspecified= and inheriting one of my typography faces.

To help the tedious task of resetting a face, I want to have a helper function that will do the work for me:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defsubst my-typography-reset (&rest faces)
  "Mark all face attributes from each face on FACES as `unspecified'."
  (custom-set-faces!
            `(,faces
              :family unspecified
              :foundry unspecified
              :width unspecified
              :height unspecified
              :weight unspecified
              :slant unspecified
              :underline unspecified
              :overline unspecified
              :strike-through unspecified
              :box unspecified
              :stipple unspecified
              :font unspecified
              :fontset unspecified
              :extend unspecified)))
#+end_src

The astute reader might ask: /"Why not have this function do the whole work of resetting the font and assign an inheritance?"/

Unfortunately at this point, the answer is not clear. When I tried to implement the /one-shot/ function, the target face would not get the inheritance value, and fonts were all messed up.

By splitting the process into cleaning and then setting, Emacs seams to behave as expected.

#+begin_note
If you know what is going on here, please let me know. I'll be more than happy to learn and credit you for that!
#+end_note

#+begin_center
◆
#+end_center

To start the configuration, I will get the Doom's font system configured accordingly to my typography:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq doom-font (face-attribute 'my-default-mono :font)
      doom-big-font (face-attribute 'my-big-face-mono :font)
      doom-variable-pitch-font (face-attribute 'my-default-prose :font))
#+end_src

It would be great if Doom could accept a /face/ as the value for these variables, but unfortunately, it does not. Until this change, I have to live with this anonymous face that copy the =font= attribute from my typography face.

The next step is to make sure the base faces used on the editor match my base typography. The process to do so is the same I will use throughout this document whenever I find a mode that I need to adjust to match the defined typography.

I first clean up all styles except color on the faces I want to configure, in this case the faces are ~fixed-pitch~ and ~variable-pitch~:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp :tangle no
(my-typography-reset 'fixed-pitch 'variable-pitch)
#+end_src

Then I set each face inheritance to the correct typography face:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp :tangle no
(custom-set-faces!
  '(fixed-pitch :inherit my-default-mono)
  '(variable-pitch :inherit my-default-prose))
#+end_src

At his point, Emacs have ~'default~, ~'fixed-pitch~, and ~'variable-pitch~ faces matching my selection of fonts. This is, probably, a major part on the typography configuration. The rest of my setup, are individual packages, which I will configure once they show up in this document.

To close out the typography section, I like to enable font smoothing on macOS. To do so, simply set ~ns-use-thin-smoothing~ to =t=:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq ns-use-thin-smoothing t)
#+end_src

*** Iconography
Doom offers the ~all-the-icons~ package, which allow one to insert Unicode glyphs on buffers. That is a great start, but the problem I see here is how inconsistent the size of these icons are.

The idea for this section is to create a list of curated icons, adjusted to occupy exactly 2 ASCII characters on the buffer. This allows for a better alignment of text when we use an Icon.

I will create an /Association List/ to store symbols associated with an adjusted icon:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
(defconst my-supported-icons
  (list 'assign       (all-the-icons-material "assignment_ind"          :height 0.95 :v-adjust -0.17)
        'bug          (all-the-icons-material "bug_report"              :height 0.95 :v-adjust -0.17)
        'busy         (all-the-icons-material "event_busy"              :height 0.95 :v-adjust -0.17)
        'calendar     (all-the-icons-octicon  "calendar"                :height 1.05 :v-adjust 0.0)
        'checked      (all-the-icons-material "check_box"               :height 0.95 :v-adjust -0.17)
        'checklist    (all-the-icons-octicon  "checklist"               :height 0.95 :v-adjust 0.1)
        'contact-add  (all-the-icons-material "person_add"              :height 0.95 :v-adjust -0.17)
        'error        (all-the-icons-material "error_outline"           :height 0.95 :v-adjust -0.17)
        'globe        (all-the-icons-faicon   "globe"                   :height 1.15 :v-adjust -0.05)
        'help         (all-the-icons-material "live_help"               :height 0.95 :v-adjust -0.22)
        'history      (all-the-icons-material "history"                 :height 0.95 :v-adjust -0.17)
        'idea         (all-the-icons-material "lightbulb_outline"       :height 0.95 :v-adjust -0.17)
        'inbox        (all-the-icons-material "inbox"                   :height 0.95 :v-adjust -0.15)
        'journal      (all-the-icons-material "book"                    :height 0.95 :v-adjust -0.15)
        'list         (all-the-icons-faicon   "list"                    :height 0.93 :v-adjust -0.05)
        'loop         (all-the-icons-material "loop"                    :height 0.95 :v-adjust -0.17)
        'meeting      (all-the-icons-material "date_range"              :height 0.95 :v-adjust -0.15)
        'new          (all-the-icons-material "new_releases"            :height 0.95 :v-adjust -0.17)
        'notes        (all-the-icons-material "library_books"           :height 0.95 :v-adjust -0.1)
        'pause        (all-the-icons-material "pause_circle_outline"    :height 0.95 :v-adjust -0.17)
        'postit       (all-the-icons-faicon   "sticky-note"             :height 1.15 :v-adjust 0.05)
        'project      (all-the-icons-octicon  "briefcase"               :height 1.05 :v-adjust 0.05)
        'review       (all-the-icons-material "rate_review"             :height 0.95 :v-adjust -0.15)
        'semi-checked (all-the-icons-material "indeterminate_check_box" :height 0.95 :v-adjust -0.17)
        'snooze       (all-the-icons-material "snooze"                  :height 0.95 :v-adjust -0.17)
        'stop         (all-the-icons-octicon  "stop"                    :height 1.05 :v-adjust -0.05)
        'timer        (all-the-icons-material "timer"                   :height 0.95 :v-adjust -0.15)
        'unchecked    (all-the-icons-material "check_box_outline_blank" :height 0.95 :v-adjust -0.17)
        'visibility   (all-the-icons-material "visibility"              :height 0.95 :v-adjust -0.17)
        'wait         (all-the-icons-material "hourglass_empty"         :height 0.95 :v-adjust -0.17))
  "Property list with all supported icons from my configuration.")
#+end_src

In order to allow other parts of this configuration to leverage the curated icons, I'll create a predicate function to check if a given symbol has an icon associated with it:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-supported-icons-p (icon)
  "Return t if the symbol given on ICON, is one associated with supported icon."
  (and (boundp 'my-supported-icons)
       (listp my-supported-icons)
       (plist-member my-supported-icons icon)))
#+end_src

I want to also create a thin-wrapper around the ~plist-get~ to retrieve the icon string for a given symbol:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-raw-icon (icon)
  "This function returns the requested ICON as if you're calling the
`all-the-icons-'* functions directly.

Icons supported by this function were all optimized to use exactly 2 characters
of space when used with the font and size defined in the main configuration.

Check the documentation of `my-supported-icons' to see the list of supported
icons."
  (plist-get my-supported-icons icon))
#+end_src

And to finalize my icons configuration, I need to expose a function where one (me in this case) will call it to get a curated icon with a given color (this is the only function in this section that a user should call to get an icon).

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-icon (icon &optional color)
  "This function returns the requested ICON as a 2-characters string,
propertized to display the associated icon from the `all-the-icons' package. It
uses the COLOR arg to 'paint' the icon.

Check documentation of the function `my-raw-icon' for a list of supported
icons."
  (cond ((eq color 'raw) (my-raw-icon icon))
        (color (propertize "--"
                   'face `(:foreground ,color)
                   'display (my-raw-icon icon)))
        (t (propertize "--"
                   'face `(:foreground ,(face-attribute 'default :foreground))
                   'display (my-raw-icon icon)))))
#+end_src

#+RESULTS:
: my-icon

*** Search Highlights

After searching, I'd like to disable the highlight of the words, like =set :noh= in vim.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (map! :leader
      :desc "Toggle search highlight"
      "t h"
      #'evil-ex-nohighlight)
#+end_src

** Special modes
The configuration in this section, belongs to some modes that I use all over the place or that are not big enough to justify their own section in this document.

In practice, most of the configurations here are about the mode's appearance, and where they show their content.

*** Info mode
The Info mode is where all user manuals exist. Up to now, I'm not used to read and search through the manuals, but I feel this is a habit I must acquire.

First I need to make the manuals to /look/ nicer (if you're rolling your eyes right now, have a remembering read into the section [[Appearances]]).

Although this is not a radical change, there are two font lock additions I want to do. The first is a symbol to represent the /menu/ for the current info page, and the second is to replace the =*= character as the list item markup, by the character I will use on all other modes that deal with lists:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! info
  (font-lock-add-keywords
   'Info-mode
   `(("^\\(\\*\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))
     ("^[\t ]*\\(\\*\\) Menu\\(:\\)"
      (0 (prog1 ()
           (compose-region (match-beginning 1) (match-end 1) "☰")
           (put-text-property (match-beginning 2) (match-end 2) 'invisible t)
           )))) t))
#+end_src

There is a package called [[https://www.emacswiki.org/emacs/InfoPlus][~info+.el~]], available through the Emacs Wiki, that fontify the ~Info-mode~ buffer to make it look nicer.

Unfortunately the latest changes introduced in March broke the package on Emacs 27 and 28, so in order to still have the nice feature it provides with a version that still works on my Emacs, I need to /pin/ the package to the version that still works:

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! info-plus :pin "5ecd4c1e3f1384bffb386e61a8e3788652e55c25")
#+end_src

Due to the nature of this package, we need to load it only when we need to fontify the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! info-plus :commands Info-toggle-fontify-all)
#+end_src

But when this actually happens? The best place to add this, is the hook ~Info-selection-hook~. First I need to define a function that will configure the mode when any info page gets selected:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info--fontify-info-h ()
  "Hook called to fontify the Info buffer.

This function lexically bind some configuration for the `into-plus' package,
and call the `Info-toggle-fontify-all' to perform the fontification work.

Notice we need to update the font lock overlays after this call to guarantee
the fontification didn't remove any important overlay."
  (let ((Info-fontify-angle-bracketed-flag nil)
        (Info-fontify-bookmarked-xrefs-flag nil)
        (Info-fontify-emphasis-flag nil)
        (Info-fontify-glossary-words nil)
        (Info-fontify-isolated-quote-flag nil)
        (Info-fontify-quotations nil)
        (Info-fontify-reference-items-flag nil)
        (Info-fontify-visited-nodes nil))
    (call-interactively 'Info-toggle-fontify-all)
    (font-lock-update)))
#+end_src

Then, I can hook it to the ~Info-selection-hook~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-selection #'my-info--fontify-info-h)
#+end_src

The next step is to make sure the ~Info-mode~ respects the typography I defined earlier. First we clean up any outstanding setup to the faces that need to get adjusted:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(my-typography-reset (cl-loop for i from 1 to 4 collect (intern (format "info-title-%d" i))))
(my-typography-reset 'info-menu-header)
#+end_src

And then, we modify all the faces to match my particular configuration:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(custom-set-faces!
  '(info-title-1 :inherit outline-1 :weight unspecified :extend unspecified)
  '(info-title-2 :inherit outline-2 :weight unspecified :extend unspecified)
  '(info-title-3 :inherit outline-3 :weight unspecified :extend unspecified)
  '(info-title-4 :inherit outline-4 :weight unspecified :extend unspecified)
  '(info-menu-header :inherit outline-5 :weight unspecified :extend unspecified)
  `(info-quoted-name :inherit font-lock-constant-face)
  `(info-isolated-quote :inherit info-quoted-name)
  `(info-isolated-backquote :inherit info-quoted-name)
  `(info-glossary-word :foreground ,(doom-color 'type 256)
                       :background ,(doom-darken 'type 0.7)
                       :box (:line-width 1 :color ,(doom-darken 'type 0.7) :style nil)
                       :inherit fixed-pitch)
  `(link-visited :foreground ,(doom-color 'violet 256))
  `(info-double-quoted-name :inherit font-lock-string-face)
  `(info-string :inherit font-lock-string-face)
  `(info-header-node :height 160
                     :inherit info-node)
  `(info-header-xref :height 160
                     :inherit info-xref))
#+end_src

There are two remaining configurations. The first one is to make the ~Info-mode~ buffer to match how it gets displayed on the editor. I will use ~writeroom~ to make the buffer centralized on the window, and will turn on ~variable-pitch-mode~:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-info-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (variable-pitch-mode 1)
  (visual-line-mode 1))
#+end_src

With the function that will configure my buffer in place, I need to hook it to the mode initialization:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! Info-mode #'my-info-buffer-config-h)
#+end_src

The last configuration for the ~Info-mode~ is *where* its buffer gets displayed. For me, it should show up on the right side of my screen. I can achieve that with a popup rule for the buffer:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*info\\*$"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)
#+end_src

*** Help mode and Man mode
I want to give a similar treatment I did to the ~Info-mode~ to both these modes, and like the ~Info-mode~, the first thing to do is to create the functions that will configure these modes:

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defun my-help-man-buffer-config-h ()
  (setq writeroom-width 75)
  (let ((+zen-text-scale 0))
    (+zen/toggle))
  (visual-line-mode 1))
#+end_src

And then, hook them up to their modes hooks:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(add-hook! (help-mode
            helpful-mode
            Man-mode
            WoMan-mode)
           #'my-help-man-buffer-config-h)
#+end_src

The last step on these configurations is to add a popup rule for each mode to make their buffers to open on the right side of the editor:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*[Hh]elp"
  :slot 2   :vslot -1     :side 'right  :width 85 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0    :quit t)

(set-popup-rule! "^\\*\\(?:Wo\\)?Man "
  :slot 2   :vslot -1     :side 'right  :width 88 :height 0.4
  :select t :modeline nil :autosave nil :ttl 0     :quit t)
#+end_src

*** Rainbow mode
The Rainbow mode is a small visual helper to display colors on the buffer, whenever it finds a string that can be a color.

I already configured a key binding (=SPC t R=) to toggle this mode.

What I still need to do, is to make sure that I use a fixed font when displaying the color text, unfortunately, the ~rainbow-mode~ uses an anonymous face to display the colors, so the only way for me to customize it, is to override the ~rainbow-colorize-match~ with a function that add any property I want to the face (in this case, to inherit from the ~fixed-pitch~ face):

#+caption: $DOOMDIR/autoload/preferences.el
#+begin_src emacs-lisp :tangle autoload/preferences.el
;;;###autoload
(defadvice! my-fontify-rainbow-colorize-match-a (color &optional match)
  "Return a matched string propertized with a face whose background is COLOR.

This function computes the foreground using `rainbow-color-luminance', and is
either white or black."
  :override 'rainbow-colorize-match
  (let ((match (or match 0)))
    (put-text-property
     (match-beginning match) (match-end match)
     'face `((:foreground ,(if (> 0.5 (rainbow-x-color-luminance color))
                               "white" "black"))
             (:background ,color)
             (:inherit fixed-pitch)))))
#+end_src

* Development
TBD

** TODO Requirements

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! lsp-ui
  :defer t
  :custom
  (lsp-ui-sideline-show-hover t)
  (lsp-ui-doc-enable t))
#+end_src

** TODO Common configuration
I set up the projectile search path for my projects

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq projectile-project-search-path '("/a/" "~/SAPDevelop/"))
#+end_src

** TODO Lisp
TBD

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(setq emacs-lisp-docstring-fill-column 80)
#+end_src

** TODO Shell script
** TODO Python
** TODO Javascript/TypeScript

* Non-editor features
TBD

** TODO Requirements
** TODO File management
Before we start configuring the target packages for this section (~dired~ and ~eshel~), I want to make some small adjustments to Treemacs. Although it is not a full blown file manager, it is a sort of a file manager for my projects, so it fits in this section.

The next change is to use our custom ~my-default-ui~ font face. I have to replace the entire ~doom-themes-enable-treemacs-variable-pitch-labels~ function with a version that uses my custom font instead. To do that, I'll use Emacs advices:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-themes-enable-treemacs-variable-pitch-labels-a (&rest _)
  "This advice changes the treemacs variable pitch font to one without serif so
the UI looks more polished."
  :override #'doom-themes-enable-treemacs-variable-pitch-labels
  (when doom-themes-treemacs-enable-variable-pitch
    (dolist (face '(treemacs-root-face
                    treemacs-git-unmodified-face
                    treemacs-git-modified-face
                    treemacs-git-renamed-face
                    treemacs-git-ignored-face
                    treemacs-git-untracked-face
                    treemacs-git-added-face
                    treemacs-git-conflict-face
                    treemacs-directory-face
                    treemacs-directory-collapsed-face
                    treemacs-file-face
                    treemacs-tags-face))
      (let ((faces (face-attribute face :inherit nil)))
        (set-face-attribute
         face nil :inherit
         `(my-default-ui ,@(delq 'unspecified (if (listp faces) faces (list faces)))))))))
#+end_src

By default, Treemacs will stay opened after you select a file to visit. Personally I don't like this, I rather have Treemacs closing when I select a file.

In order to help me achieve my desired behavior, I'll  create another /autoload/ function that I'll call when I select a file:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-visit-node-and-close-h (&optional arg)
  "Closes treemacs window after selecting a file to visit."
  (treemacs-visit-node-default arg)
  (delete-window (treemacs-get-local-window)))
#+end_src

We can now, configure Treemacs properly:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! treemacs
#+end_src

First we need to tell Treemacs to use the new autoload function when I press =<ENTER>= on a file:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (treemacs-define-RET-action 'file-node-open #'my-treemacs-visit-node-and-close-h)
  (treemacs-define-RET-action 'file-node-closed #'my-treemacs-visit-node-and-close-h)
#+end_src

Then, I like Treemacs to collapse directory into one when possible:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (setq treemacs-collapse-dirs (if (executable-find "python3") 3 0))
#+end_src

https://andreyorst.gitlab.io/posts/2020-05-01-dynamic-title-for-treemacs-workspace/

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-treemacs-buffer-config-h ()
  (let ((bg (face-attribute 'default :background))
        (fg (face-attribute 'default :foreground)))
    (face-remap-add-relative 'header-line
                             :background bg :foreground fg
                             :box `(:line-width ,(/ my-line-pixel-height 2) :color ,bg)))
  (setq header-line-format
        '((:eval
           (concat
            " ☰ "
            (propertize (s-titleize (persp-current-name)) 'face 'my-ui-window-header))))))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  (add-hook 'treemacs-mode-hook #'my-treemacs-buffer-config-h)
#+end_src

And finally, we can close our Treemacs configuration

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
  )
#+end_src

I also like to make sure it behaves as expected if I use the mouse:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map!
 (:after treemacs
  (:map treemacs-mode-map
   [mouse-1] #'treemacs-single-click-expand-action))

 (:after treemacs-evil
  (:map evil-treemacs-state-map
   "C-h" #'evil-window-left
   "C-l" #'evil-window-right))

 (:after cfrs
  (:map cfrs-input-mode-map
   :n [escape] #'cfrs-cancel)))
#+end_src

Treemacs offers a function that adds the current project if it is not on the workspace. That is a nice feature, but because I use workspaces heavily, the fact that this function does not /remove/ projects that do not belong to this workspace bothers me, so I  wrote this advice to do the dirty work for me:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defadvice! my-treemacs-add-and-display-current-project-a ()
  "Open treemacs with current project. This function removes any project that is
not the current one."
  :override #'treemacs-add-and-display-current-project
  (interactive)

  (cl-dolist (p (treemacs-workspace->projects (treemacs-current-workspace)))
    (unless (string= (doom-project-name) (treemacs-project->name p))
      (treemacs-do-remove-project-from-workspace p t)))

  (when (treemacs-workspace->is-empty?)
      (treemacs-do-add-project-to-workspace (doom-project-root) (doom-project-name)))

  (treemacs-select-window)
  (treemacs-pulse-on-success))
#+end_src

And to finalize the Treemacs configuration, let's make it respect my window navigation keys:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-toggle-git-mode ()
  "Toggle `dired-git-info-mode' in git repos."
  (interactive)
  (when (and (not (file-remote-p default-directory))
             (locate-dominating-file "." ".git"))
    (call-interactively 'dired-git-info-mode)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-directory ()
  "Enters in the directory at point. If the cursor is not on a directory, do
nothing."
  (interactive)
  (let ((target-file (dired-get-file-for-visit)))
    (when (or (file-directory-p target-file)
              (dired-avfs--archive-p target-file))
      (dired-find-file))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-mac-quick-view ()
  "Invoke the macOS Quiclview on the file under point."
  (interactive)
  (shell-command (concat "qlmanage -p \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-widen-or-quit-all ()
  "If `dired-narow' is on, revert to the normal view. If there is no active
narrow, quit Dired."
  (interactive)
  (if dired-narrow-mode
      (revert-buffer)
    (mapc (lambda (buf)
            (let ((win (get-buffer-window buf)))
              (unless (append (window-prev-buffers win) (window-prev-buffers win))
                (delete-window win))
              (kill-buffer buf)))
          (doom-buffers-in-mode 'dired-mode))))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-narrow (narrow-func)
  "Start a dynamic narrowing of files in current view."
  (interactive
   (list (if current-prefix-arg
             'dired-narrow-fuzzy
           'dired-narrow-regexp)))
  (call-interactively narrow-func))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-yank-absolute-path ()
  "Copy the absolute path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill 0))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-yank-relative-path ()
  "Copy the relative path of file on pointer to kill ring."
  (interactive)
  (dired-copy-filename-as-kill))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-externally ()
  "Open file with application defined by OS."
  (interactive)
  (shell-command (concat "open \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-reveal-on-finder ()
  "Show current file in Finder."
  (interactive)
  (shell-command (concat "open --reveal \""
                         (dired-get-file-for-visit)
                         "\" > /dev/null 2>&1")))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-marked-file-p ()
  "Return non-nil if we have marked file at point."
  (dired-file-marker (dired-get-file-for-visit)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-toggle-mark (&optional _)
  "Toggle mark of file at point."
  (interactive)
  (if (my-dired-marked-file-p)
      (dired-unmark 1)
    (dired-mark 1)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-split-right ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-right)
                           'window)))
#+end_src

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-dired-open-split-bellow ()
  (interactive)
  (select-window
   (window--display-buffer (find-file-noselect (dired-get-file-for-visit))
                           (split-window-below)
                           'window)))
#+end_src

- https://github.com/Fuco1/dired-hacks for all packages
- https://blog.breadncup.com/2012/05/27/emacs-sunrise-commander-and-avfs-fuse-unionfs-fuse-in-mac-os-x-lion/ for starting the avfsd service

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! dired-collapse)
(package! dired-narrow)
(package! dired-ranger)
(package! dired-quick-sort)
(package! dired-avfs)
(package! peep-dired)
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! dired
  (setq
        auto-revert-verbose nil
        dired-dwim-target t
        dired-listing-switches "-lAhvFoG --group-directories-first"
        dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$\\|^.DS_STORE$\\|^.projectile$"
        dired-recursive-copies '(always)
        dired-recursive-deletes '(top)
        dired-use-ls-dired t
        global-auto-revert-non-file-buffers t
        insert-directory-program "gls"
        wdired-allow-to-change-permissions t
        wdired-allow-to-redirect-links t
        wdired-confirm-overwrite t))

(use-package! peep-dired
  :after dired
  :init
  (setq peep-dired-cleanup-on-disable t
        peep-dired-cleanup-eagerly t
        peep-dired-enable-on-directories nil))
(use-package! dired-collapse :after dired)
(use-package! dired-narrow :after dired)
(use-package! dired-quick-sort
  :hook ((dired-mode . dired-quick-sort)))
(use-package! dired-avfs
  :after dired
  :init
  (setq dired-avfs-root "~/.local/var/avfs"))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after dired
      (:map dired-mode-map
       :ne "t"        nil
       :ne "y"        nil
       :ne "c"        nil
       :ne "o"        nil
       :ne "m"        nil
       :ne "/"        #'my-dired-narrow
       :ne "<escape>" #'my-dired-widen-or-quit-all
       :ne "q"        #'my-dired-widen-or-quit-all
       :ne "RET"      #'dired-find-file
       :ne "TAB"      #'my-dired-open-directory
       :ne "<tab>"    #'my-dired-open-directory
       :ne "j"        #'dired-next-line
       :ne "k"        #'dired-previous-line
       :ne "l"        #'my-dired-open-directory
       :ne "h"        #'dired-up-directory
       :ne "U"        #'dired-up-directory
       :ne "R"        #'dired-do-rename
       :ne "d"        #'dired-do-delete
       :ne "x"        #'my-dired-toggle-mark
       :ne "p"        #'dired-ranger-paste
       :ne "M"        #'dired-ranger-move
       :ne "`"        #'dired-ranger-bookmark
       :ne "'"        #'dired-ranger-bookmark-visit
       (:prefix ("c" . "create")
        :desc "Create empty file"     :ne "f" #'dired-create-empty-file
        :desc "Create directory"      :ne "d" #'dired-create-directory
        :desc "Create project"        :ne "p" #'xxx)
       (:prefix ("m" . "mark")
        :ne "h" nil
        :desc "Mark directories"  :ne "d" #'dired-mark-directories
        :desc "Mark extension"    :ne "e" #'dired-mark-extension
        :desc "Mark hidden files" :ne "h" #'dired-mark-omitted
        :desc "Mark with regexp"  :ne "r" #'dired-mark-files-regexp
        :desc "Mark subdir files" :ne "s" #'dired-mark-omitted
        :desc "Unmark all files"  :ne "u" #'dired-unmark-all-files
        :desc "Remove all marks"  :ne "U" #'dired-unmark-all-marks
        :desc "Mark executables"  :ne "x" #'dired-mark-executables)
       (:prefix ("o" . "open")
        :desc "Open no split"         :ne "o" #'dired-find-alternate-file
        :desc "Quick view"            :ne "q" #'my-dired-mac-quick-view
        :desc "Reveal on Finder"      :ne "f" #'my-dired-reveal-on-finder
        :desc "Open vertically"       :ne "s" #'my-dired-open-split-bellow
        :desc "Open horizontally"     :ne "v" #'my-dired-open-split-right
        :desc "Open externally"       :ne "x" #'my-dired-open-externally)
       (:prefix ("t" . "toggle")
        :desc "Toggle collapsed dirs" :ne "c" #'dired-collapse-mode
        :desc "Toggle details"        :ne "d" #'dired-hide-details-mode
        :desc "Toggle git info"       :ne "g" #'my-dired-toggle-git-mode
        :desc "Toggle hidden files"   :ne "h" #'dired-omit-mode
        :desc "Toggle all marks"      :ne "m" #'dired-toggle-marks
        :desc "Toggle preview"        :ne "p" #'peep-dired
        :desc "Toggle sorting"        :ne "s" #'hydra-dired-quick-sort/body
        :desc "Toggle edit mode"      :ne "w" #'wdired-change-to-wdired-mode)
       (:prefix ("y" . "yank")
        :desc "Yank files"            :ne "y" #'dired-ranger-copy
        :desc "Copy absolut path"     :ne "a" #'my-dired-yank-absolute-path
        :desc "Copy file"             :ne "f" #'dired-do-copy
        :desc "Copy with regexp"      :ne "R" #'dired-do-copy-regexp
        :desc "Copy relative path"    :ne "r" #'my-dired-yank-relative-path))
      (:map wdired-mode-map
        :in "s-RET" #'wdired-finish-edit
        :in [s-return] #'wdired-finish-edit
        :in "s-ESC" #'wdired-revert
        :in [s-escape] #'wdired-revert))
#+end_src

** TODO Project management
Projectile is a great package. It usually provides more features that one particular user would need. But I still want to tweak it to make it behave more according my expectations.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-ignored-projects `("~/"
                                      "/tmp"
                                      ,(expand-file-name "straight/repos" doom-local-dir))))
#+end_src

Doom sets a function to run when we open a project with ~projectile~, but that function is not calling any /open file/ function for us. Let's create our own version of such function and help projectile to do the appropriate thing when we open a project.

The actions I expect are:

- Check if the project has one of the recognized files and open it, in this order (we should look for four extensions on each one of the files, also in this order: =.org=, no extension, =.md=, and =.rst=):
  + =CHANGELOG=
  + =NEWS=
  + =README=
- If none of the recognizable files is present, run ~project-find-file~;

Let's create such function as an /autoload/ function:

#+caption: $DOOMDIR/autoload/extras.el
#+begin_src emacs-lisp :tangle autoload/extras.el
;;;###autoload
(defun my-after-switch-project-action-h (dir)
  "A project first action to execute when we switch our current project."
  (let ((file (file-exists-p! (ignore-errors (expand-file-name (or "README.org"
                                                                   "README.md"
                                                                   "README"
                                                                   "README.rst"
                                                                   "NEWS.org"
                                                                   "NEWS.md"
                                                                   "NEWS"
                                                                   "NEWS.rst"
                                                                   "CHANGELOG.org"
                                                                   "CHANGELOG.md"
                                                                   "CHANGELOG"
                                                                   "CHANGELOG.rst") dir)))))
    (if file
        (find-file file)
      (doom-project-find-file dir))))
#+end_src

And attach it to the ~projectile~ hook:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! projectile
  (setq +workspaces-switch-project-function #'my-after-switch-project-action-h))
#+end_src

** TODO Terminal
In general, I really like the setup Doom has for the terminal. There are 3 things I like to add there.

One are some aliases that I'm used to use when working on the terminal:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(after! eshell
  (set-eshell-alias!
   "d"     "dired $1"
   "edit"  "find-file-other-window $1"
   "em"    "find-file-other-window $1"
   "emacs" "find-file-other-window $1"
   "f"     "find-file $1"
   "gc"    "magit-commit $1"
   "gl"    "(call-interactively 'magit-log-current)"
   "gst"   "magit-status $1"
   "ls"    "exa --group-directories-first --color always -F $1"
   "la"    "exa --group-directories-first --color always -F -a $1"
   "ll"    "exa --group-directories-first --color always -F -l -h --git $1"
   "lla"   "exa --group-directories-first --color always -F -a -l -h --git $1"
   "rg"    "rg --color=always $*"
   "up"    "eshell-up $1"
   "pk"    "eshell-up-peek $1"
   "vi"    "find-file-other-window $1"
   "vim"   "find-file-other-window $1"))
#+end_src

Two is the window navigation mapping:

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(map! :after eshell
      (:map eshell-mode-map
       :in "C-h" #'evil-window-left
       :in "C-j" #'evil-window-down
       :in "C-k" #'evil-window-up
       :in "C-l" #'evil-window-right))
#+end_src

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(set-popup-rule! "^\\*doom:\\(?:v?term\\|e?shell\\)-popup"
  :slot 2   :vslot -1     :side 'bottom  :width 110 :height 0.4
  :select t :modeline nil :autosave nil  :ttl nil   :quit nil)
#+end_src

And three is to fix ~magit-status~. When I'm on the terminal, if I open ~magit-status~, everything works as expected, but when I exit back to the terminal, Emacs switch the buffer on my terminal window to something else.

The ideal behavior would be to any app launch from the terminal to take over eshell's window until done. Then, revert back to the terminal.

I like to have a hint of the next possible completion while I'm working on shell. Zsh and Fish have great plugins for such feature, so I decided to add one for eshell as well:

- https://github.com/dieggsy/esh-autosuggest

#+caption: $DOOMDIR/packages.el
#+begin_src emacs-lisp :tangle packages.el
(package! esh-autosuggest)
#+end_src

The only configuration we need to get this mode working, is to let Emacs enable it when ~eshell-mode~ is up.

#+caption: $DOOMDIR/config.el
#+begin_src emacs-lisp
(use-package! esh-autosuggest
  :defer t
  :hook ((eshell-mode . esh-autosuggest-mode)))
#+end_src

* Appendix

** The =init.el= file
We can't tangle the =init.el= on Doom because it is always loaded before =doom sync= starts tangling =config.org=.

I have two alternatives here:

1. Let =init.el= as a lisp package;
2. Create a =doom sync= extension to tangle a =init.org= file;

For now, I will keep it as a separated Lisp file that I'm reproducing in this appendix for sake of documentation:

#+caption: $DOOMDIR/init.el
#+include: "~/.config/doom/init.el" src emacs-lisp :tangle no

** List of tables
#+TOC: tables

** List of figures
- [[fig:caco-demon][Figure 1: My favorite contender for a Doom Emacs logo]]
